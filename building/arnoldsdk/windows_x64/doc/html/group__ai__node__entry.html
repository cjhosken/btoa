<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<title>Arnold 7.3.5.0 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">AtNodeEntry API</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> methods.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtCommonMethods.html">AtCommonMethods</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Methods common to all nodes.  <a href="structAtCommonMethods.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtNodeMethods.html">AtNodeMethods</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node methods.  <a href="structAtNodeMethods.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtMetaDataEntry.html">AtMetaDataEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAtNodeEntry.html">AtNodeEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This represents a node type in Arnold.  <a href="structAtNodeEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga63573be57e2588a975c0774a61794cec"><td class="memItemLeft" align="right" valign="top"><a id="ga63573be57e2588a975c0774a61794cec" name="ga63573be57e2588a975c0774a61794cec"></a>
bool(*&#160;</td><td class="memItemRight" valign="bottom"><b>AtCommonMethods::PluginInitialize</b> )(void **)</td></tr>
<tr class="separator:ga63573be57e2588a975c0774a61794cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40957b7353ecc3de14a52e300ffb72ea"><td class="memItemLeft" align="right" valign="top"><a id="ga40957b7353ecc3de14a52e300ffb72ea" name="ga40957b7353ecc3de14a52e300ffb72ea"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>AtCommonMethods::PluginCleanup</b> )(void *)</td></tr>
<tr class="separator:ga40957b7353ecc3de14a52e300ffb72ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc0d41436e7d8cd99b0091b5a07067c0"><td class="memItemLeft" align="right" valign="top"><a id="gadc0d41436e7d8cd99b0091b5a07067c0" name="gadc0d41436e7d8cd99b0091b5a07067c0"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>AtCommonMethods::Parameters</b> )(AtList *, <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *)</td></tr>
<tr class="separator:gadc0d41436e7d8cd99b0091b5a07067c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4c66c774acb0e27b2c5528c9c57f61b"><td class="memItemLeft" align="right" valign="top"><a id="gad4c66c774acb0e27b2c5528c9c57f61b" name="gad4c66c774acb0e27b2c5528c9c57f61b"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>AtCommonMethods::Initialize</b> )(AtRenderSession *, <a class="el" href="structAtNode.html">AtNode</a> *)</td></tr>
<tr class="separator:gad4c66c774acb0e27b2c5528c9c57f61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3faed8edbcf644d90150f15921dc9ff5"><td class="memItemLeft" align="right" valign="top"><a id="ga3faed8edbcf644d90150f15921dc9ff5" name="ga3faed8edbcf644d90150f15921dc9ff5"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>AtCommonMethods::Update</b> )(AtRenderSession *, <a class="el" href="structAtNode.html">AtNode</a> *)</td></tr>
<tr class="separator:ga3faed8edbcf644d90150f15921dc9ff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa96c444fd1602caac415be2f9c58479"><td class="memItemLeft" align="right" valign="top"><a id="gaaa96c444fd1602caac415be2f9c58479" name="gaaa96c444fd1602caac415be2f9c58479"></a>
void(*&#160;</td><td class="memItemRight" valign="bottom"><b>AtCommonMethods::Finish</b> )(<a class="el" href="structAtNode.html">AtNode</a> *)</td></tr>
<tr class="separator:gaaa96c444fd1602caac415be2f9c58479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga407dba69b8aa7e88fee4ba4e5f048068"><td class="memItemLeft" align="right" valign="top"><a id="ga407dba69b8aa7e88fee4ba4e5f048068" name="ga407dba69b8aa7e88fee4ba4e5f048068"></a>
const <a class="el" href="structAtCommonMethods.html">AtCommonMethods</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>AtNodeMethods::cmethods</b></td></tr>
<tr class="memdesc:ga407dba69b8aa7e88fee4ba4e5f048068"><td class="mdescLeft">&#160;</td><td class="mdescRight">common methods <br  />
 <br /></td></tr>
<tr class="separator:ga407dba69b8aa7e88fee4ba4e5f048068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51412d97dcfa86c1c41ed6bcf37ab085"><td class="memItemLeft" align="right" valign="top"><a id="ga51412d97dcfa86c1c41ed6bcf37ab085" name="ga51412d97dcfa86c1c41ed6bcf37ab085"></a>
const void *&#160;</td><td class="memItemRight" valign="bottom"><b>AtNodeMethods::dmethods</b></td></tr>
<tr class="memdesc:ga51412d97dcfa86c1c41ed6bcf37ab085"><td class="mdescLeft">&#160;</td><td class="mdescRight">derived methods <br  />
 <br /></td></tr>
<tr class="separator:ga51412d97dcfa86c1c41ed6bcf37ab085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f67f2c7ed6bc2f673961dd8edac1e7a"><td class="memItemLeft" align="right" valign="top"><a id="ga3f67f2c7ed6bc2f673961dd8edac1e7a" name="ga3f67f2c7ed6bc2f673961dd8edac1e7a"></a>
<a class="el" href="classAtString.html">AtString</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtMetaDataEntry::name</b></td></tr>
<tr class="separator:ga3f67f2c7ed6bc2f673961dd8edac1e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga650780ff1b92624507db4d99f070fcb6"><td class="memItemLeft" align="right" valign="top"><a id="ga650780ff1b92624507db4d99f070fcb6" name="ga650780ff1b92624507db4d99f070fcb6"></a>
<a class="el" href="classAtString.html">AtString</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtMetaDataEntry::param</b></td></tr>
<tr class="separator:ga650780ff1b92624507db4d99f070fcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef96a1634a3f18521770bb534b6f9ad1"><td class="memItemLeft" align="right" valign="top"><a id="gaef96a1634a3f18521770bb534b6f9ad1" name="gaef96a1634a3f18521770bb534b6f9ad1"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>AtMetaDataEntry::type</b></td></tr>
<tr class="separator:gaef96a1634a3f18521770bb534b6f9ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace6fe6e48a847907701ae7c80884fb09"><td class="memItemLeft" align="right" valign="top"><a id="gace6fe6e48a847907701ae7c80884fb09" name="gace6fe6e48a847907701ae7c80884fb09"></a>
<a class="el" href="classAtParamValue.html">AtParamValue</a>&#160;</td><td class="memItemRight" valign="bottom"><b>AtMetaDataEntry::value</b></td></tr>
<tr class="separator:gace6fe6e48a847907701ae7c80884fb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">AtNodeEntry Methods</h2></td></tr>
<tr class="memitem:gac7f9366415f0bcf9e695e0bdd0c37468"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gac7f9366415f0bcf9e695e0bdd0c37468">AiNodeEntryLookUp</a> (const <a class="el" href="classAtString.html">AtString</a> name)</td></tr>
<tr class="memdesc:gac7f9366415f0bcf9e695e0bdd0c37468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a node entry from a name string.  <a href="group__ai__node__entry.html#gac7f9366415f0bcf9e695e0bdd0c37468">More...</a><br /></td></tr>
<tr class="separator:gac7f9366415f0bcf9e695e0bdd0c37468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74710b24e1206787d037b5b60e98962f"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga74710b24e1206787d037b5b60e98962f">AiNodeEntryGetName</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:ga74710b24e1206787d037b5b60e98962f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>.  <a href="group__ai__node__entry.html#ga74710b24e1206787d037b5b60e98962f">More...</a><br /></td></tr>
<tr class="separator:ga74710b24e1206787d037b5b60e98962f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5689647a4f155fa357f32b1d0907c46"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE <a class="el" href="classAtString.html">AtString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gaf5689647a4f155fa357f32b1d0907c46">AiNodeEntryGetNameAtString</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:gaf5689647a4f155fa357f32b1d0907c46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the name of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a> as an <a class="el" href="classAtString.html" title="Arnold String allows for fast string comparisons.">AtString</a>.  <a href="group__ai__node__entry.html#gaf5689647a4f155fa357f32b1d0907c46">More...</a><br /></td></tr>
<tr class="separator:gaf5689647a4f155fa357f32b1d0907c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01f300beb73f6b1a19b1e2a0990ce417"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga01f300beb73f6b1a19b1e2a0990ce417">AiNodeEntryGetType</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:ga01f300beb73f6b1a19b1e2a0990ce417"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>.  <a href="group__ai__node__entry.html#ga01f300beb73f6b1a19b1e2a0990ce417">More...</a><br /></td></tr>
<tr class="separator:ga01f300beb73f6b1a19b1e2a0990ce417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade0b4cad1512a32ae1b6a0e6b60c0047"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gade0b4cad1512a32ae1b6a0e6b60c0047">AiNodeEntryGetTypeName</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:gade0b4cad1512a32ae1b6a0e6b60c0047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the type of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a> as a string.  <a href="group__ai__node__entry.html#gade0b4cad1512a32ae1b6a0e6b60c0047">More...</a><br /></td></tr>
<tr class="separator:gade0b4cad1512a32ae1b6a0e6b60c0047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a4a92ffec45e0decb0154904ccba96"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga27a4a92ffec45e0decb0154904ccba96">AiNodeEntryGetDerivedType</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:ga27a4a92ffec45e0decb0154904ccba96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the derived type of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>.  <a href="group__ai__node__entry.html#ga27a4a92ffec45e0decb0154904ccba96">More...</a><br /></td></tr>
<tr class="separator:ga27a4a92ffec45e0decb0154904ccba96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8447a93f7e0c8ba11838175cfef2af7d"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga8447a93f7e0c8ba11838175cfef2af7d">AiNodeEntryGetDerivedTypeName</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:ga8447a93f7e0c8ba11838175cfef2af7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the derived type of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a> as a string, if applicable.  <a href="group__ai__node__entry.html#ga8447a93f7e0c8ba11838175cfef2af7d">More...</a><br /></td></tr>
<tr class="separator:ga8447a93f7e0c8ba11838175cfef2af7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga490b4adfc99ef9382fd31ac6faf1d9ed"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga490b4adfc99ef9382fd31ac6faf1d9ed">AiNodeEntryGetOutputType</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:ga490b4adfc99ef9382fd31ac6faf1d9ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the output type of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>.  <a href="group__ai__node__entry.html#ga490b4adfc99ef9382fd31ac6faf1d9ed">More...</a><br /></td></tr>
<tr class="separator:ga490b4adfc99ef9382fd31ac6faf1d9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e02359d1894eafecd4b1a5e4c9f2658"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga5e02359d1894eafecd4b1a5e4c9f2658">AiNodeEntryGetFilename</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:ga5e02359d1894eafecd4b1a5e4c9f2658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the filename (so/dll path) of an <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>.  <a href="group__ai__node__entry.html#ga5e02359d1894eafecd4b1a5e4c9f2658">More...</a><br /></td></tr>
<tr class="separator:ga5e02359d1894eafecd4b1a5e4c9f2658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5be14131550f8c9c207f2a5e56a2b41"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gae5be14131550f8c9c207f2a5e56a2b41">AiNodeEntryGetVersion</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:gae5be14131550f8c9c207f2a5e56a2b41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the version that this node was linked with.  <a href="group__ai__node__entry.html#gae5be14131550f8c9c207f2a5e56a2b41">More...</a><br /></td></tr>
<tr class="separator:gae5be14131550f8c9c207f2a5e56a2b41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b310c954bc66a54c299e9e98396a18a"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga9b310c954bc66a54c299e9e98396a18a">AiNodeEntryGetCount</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:ga9b310c954bc66a54c299e9e98396a18a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of instances of a particular node.  <a href="group__ai__node__entry.html#ga9b310c954bc66a54c299e9e98396a18a">More...</a><br /></td></tr>
<tr class="separator:ga9b310c954bc66a54c299e9e98396a18a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c5feea77852d4c4ca63ef5c9a06e299"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga3c5feea77852d4c4ca63ef5c9a06e299">AiNodeEntryGetNumParams</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:ga3c5feea77852d4c4ca63ef5c9a06e299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of parameters of a given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>.  <a href="group__ai__node__entry.html#ga3c5feea77852d4c4ca63ef5c9a06e299">More...</a><br /></td></tr>
<tr class="separator:ga3c5feea77852d4c4ca63ef5c9a06e299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66ccecb71a33bb7c757a04afbb7edbe4"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const AtParamEntry *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga66ccecb71a33bb7c757a04afbb7edbe4">AiNodeEntryGetParameter</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry, int i)</td></tr>
<tr class="memdesc:ga66ccecb71a33bb7c757a04afbb7edbe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i'th parameter in an <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>.  <a href="group__ai__node__entry.html#ga66ccecb71a33bb7c757a04afbb7edbe4">More...</a><br /></td></tr>
<tr class="separator:ga66ccecb71a33bb7c757a04afbb7edbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0bb08145b24fcc740566cbd7fcd09e6a"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const AtParamEntry *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga0bb08145b24fcc740566cbd7fcd09e6a">AiNodeEntryLookUpParameter</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="memdesc:ga0bb08145b24fcc740566cbd7fcd09e6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up a parameter in a node entry from a name string.  <a href="group__ai__node__entry.html#ga0bb08145b24fcc740566cbd7fcd09e6a">More...</a><br /></td></tr>
<tr class="separator:ga0bb08145b24fcc740566cbd7fcd09e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3684b0531c0ad8bd46787d2523695076"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga3684b0531c0ad8bd46787d2523695076">AiNodeEntryGetNumOutputs</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:ga3684b0531c0ad8bd46787d2523695076"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of outputs of a given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>.  <a href="group__ai__node__entry.html#ga3684b0531c0ad8bd46787d2523695076">More...</a><br /></td></tr>
<tr class="separator:ga3684b0531c0ad8bd46787d2523695076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39b4f5b9eb2e36b1e2b164b09260b1c8"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const AtParamEntry *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga39b4f5b9eb2e36b1e2b164b09260b1c8">AiNodeEntryGetOutput</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry, int i)</td></tr>
<tr class="memdesc:ga39b4f5b9eb2e36b1e2b164b09260b1c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the i'th output AtParamEntry in an <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>.  <a href="group__ai__node__entry.html#ga39b4f5b9eb2e36b1e2b164b09260b1c8">More...</a><br /></td></tr>
<tr class="separator:ga39b4f5b9eb2e36b1e2b164b09260b1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b7a9204bfce96ee08c0804bcea36bf8"><td class="memItemLeft" align="right" valign="top">AI_API AI_PURE const AtParamEntry *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga2b7a9204bfce96ee08c0804bcea36bf8">AiNodeEntryLookUpOutput</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry, const <a class="el" href="classAtString.html">AtString</a> param)</td></tr>
<tr class="memdesc:ga2b7a9204bfce96ee08c0804bcea36bf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up an output parameter in a node entry from a name string.  <a href="group__ai__node__entry.html#ga2b7a9204bfce96ee08c0804bcea36bf8">More...</a><br /></td></tr>
<tr class="separator:ga2b7a9204bfce96ee08c0804bcea36bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63613f6f4f85290a7b2a2c02441d2b3e"><td class="memItemLeft" align="right" valign="top"><a id="ga63613f6f4f85290a7b2a2c02441d2b3e" name="ga63613f6f4f85290a7b2a2c02441d2b3e"></a>
AI_DEPRECATED const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeEntryLookUp</b> (const char *name)</td></tr>
<tr class="separator:ga63613f6f4f85290a7b2a2c02441d2b3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1564953585b21a3c3231d7900571090"><td class="memItemLeft" align="right" valign="top"><a id="gaf1564953585b21a3c3231d7900571090" name="gaf1564953585b21a3c3231d7900571090"></a>
AI_DEPRECATED const AtParamEntry *&#160;</td><td class="memItemRight" valign="bottom"><b>AiNodeEntryLookUpParameter</b> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry, const char *param)</td></tr>
<tr class="separator:gaf1564953585b21a3c3231d7900571090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad75672e2b0955b64c9b6f11b409643b3"><td class="memItemLeft" align="right" valign="top">AI_API AtParamIterator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gad75672e2b0955b64c9b6f11b409643b3">AiNodeEntryGetParamIterator</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry)</td></tr>
<tr class="memdesc:gad75672e2b0955b64c9b6f11b409643b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new AtParamIterator for this node entry.  <a href="group__ai__node__entry.html#gad75672e2b0955b64c9b6f11b409643b3">More...</a><br /></td></tr>
<tr class="separator:gad75672e2b0955b64c9b6f11b409643b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad10f698b43b1ad4c626318803d02f71d"><td class="memItemLeft" align="right" valign="top">AI_API AtMetaDataIterator *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gad10f698b43b1ad4c626318803d02f71d">AiNodeEntryGetMetaDataIterator</a> (const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *nentry, const char *param=NULL)</td></tr>
<tr class="memdesc:gad10f698b43b1ad4c626318803d02f71d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates and returns a new AtMetaDataIterator for this node entry.  <a href="group__ai__node__entry.html#gad10f698b43b1ad4c626318803d02f71d">More...</a><br /></td></tr>
<tr class="separator:gad10f698b43b1ad4c626318803d02f71d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga000f6845aff3227c1091cf979e1666ce"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga000f6845aff3227c1091cf979e1666ce">AiNodeEntryInstall</a> (int type, uint8_t output_type, const char *name, const char *filename, const <a class="el" href="structAtNodeMethods.html">AtNodeMethods</a> *methods, const char *version)</td></tr>
<tr class="memdesc:ga000f6845aff3227c1091cf979e1666ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a new node in the system.  <a href="group__ai__node__entry.html#ga000f6845aff3227c1091cf979e1666ce">More...</a><br /></td></tr>
<tr class="separator:ga000f6845aff3227c1091cf979e1666ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6abc6229eb77d0096810f4fee1befcd2"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga6abc6229eb77d0096810f4fee1befcd2">AiNodeEntryUninstall</a> (const char *name)</td></tr>
<tr class="memdesc:ga6abc6229eb77d0096810f4fee1befcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninstall a node from the system.  <a href="group__ai__node__entry.html#ga6abc6229eb77d0096810f4fee1befcd2">More...</a><br /></td></tr>
<tr class="separator:ga6abc6229eb77d0096810f4fee1befcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">AtParamIterator Methods</h2></td></tr>
<tr class="memitem:ga305c25e73f44db3aec114b5af9e996b1"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga305c25e73f44db3aec114b5af9e996b1">AiParamIteratorDestroy</a> (AtParamIterator *iter)</td></tr>
<tr class="memdesc:ga305c25e73f44db3aec114b5af9e996b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a param iterator when it is no longer needed.  <a href="group__ai__node__entry.html#ga305c25e73f44db3aec114b5af9e996b1">More...</a><br /></td></tr>
<tr class="separator:ga305c25e73f44db3aec114b5af9e996b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4e2ac734015e40d9954f78c0469439"><td class="memItemLeft" align="right" valign="top">AI_API const AtParamEntry *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga6d4e2ac734015e40d9954f78c0469439">AiParamIteratorGetNext</a> (AtParamIterator *iter)</td></tr>
<tr class="memdesc:ga6d4e2ac734015e40d9954f78c0469439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current param entry and points param iterator to the next one.  <a href="group__ai__node__entry.html#ga6d4e2ac734015e40d9954f78c0469439">More...</a><br /></td></tr>
<tr class="separator:ga6d4e2ac734015e40d9954f78c0469439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2d3ab8b20294363c89fd694596de145"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gac2d3ab8b20294363c89fd694596de145">AiParamIteratorFinished</a> (const AtParamIterator *iter)</td></tr>
<tr class="memdesc:gac2d3ab8b20294363c89fd694596de145"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there are no more parameters to iterate over.  <a href="group__ai__node__entry.html#gac2d3ab8b20294363c89fd694596de145">More...</a><br /></td></tr>
<tr class="separator:gac2d3ab8b20294363c89fd694596de145"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">AtMetaDataIterator Methods</h2></td></tr>
<tr class="memitem:gafa165f4d801d854b7ef0bc757f96fe16"><td class="memItemLeft" align="right" valign="top">AI_API void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gafa165f4d801d854b7ef0bc757f96fe16">AiMetaDataIteratorDestroy</a> (AtMetaDataIterator *iter)</td></tr>
<tr class="memdesc:gafa165f4d801d854b7ef0bc757f96fe16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a metadata iterator when it is no longer needed.  <a href="group__ai__node__entry.html#gafa165f4d801d854b7ef0bc757f96fe16">More...</a><br /></td></tr>
<tr class="separator:gafa165f4d801d854b7ef0bc757f96fe16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1fe52c23c2935e2b46f1e47387073a7"><td class="memItemLeft" align="right" valign="top">AI_API const <a class="el" href="structAtMetaDataEntry.html">AtMetaDataEntry</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#gaf1fe52c23c2935e2b46f1e47387073a7">AiMetaDataIteratorGetNext</a> (AtMetaDataIterator *iter)</td></tr>
<tr class="memdesc:gaf1fe52c23c2935e2b46f1e47387073a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns current metadata entry and points metadata iterator to the next one.  <a href="group__ai__node__entry.html#gaf1fe52c23c2935e2b46f1e47387073a7">More...</a><br /></td></tr>
<tr class="separator:gaf1fe52c23c2935e2b46f1e47387073a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ed3ad36805c2a2b850c9e776193a0de"><td class="memItemLeft" align="right" valign="top">AI_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__node__entry.html#ga2ed3ad36805c2a2b850c9e776193a0de">AiMetaDataIteratorFinished</a> (const AtMetaDataIterator *iter)</td></tr>
<tr class="memdesc:ga2ed3ad36805c2a2b850c9e776193a0de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is no more metadata to iterate over.  <a href="group__ai__node__entry.html#ga2ed3ad36805c2a2b850c9e776193a0de">More...</a><br /></td></tr>
<tr class="separator:ga2ed3ad36805c2a2b850c9e776193a0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Node Types</h2></td></tr>
<tr class="memitem:ga2ca2a3cc668472f3d8b2a745bb28099b"><td class="memItemLeft" align="right" valign="top"><a id="ga2ca2a3cc668472f3d8b2a745bb28099b" name="ga2ca2a3cc668472f3d8b2a745bb28099b"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NODE_UNDEFINED</b>&#160;&#160;&#160;0x0000</td></tr>
<tr class="memdesc:ga2ca2a3cc668472f3d8b2a745bb28099b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undefined type. <br /></td></tr>
<tr class="separator:ga2ca2a3cc668472f3d8b2a745bb28099b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb7eae92aa44ac7b928e50b1f4e0fcb6"><td class="memItemLeft" align="right" valign="top"><a id="gabb7eae92aa44ac7b928e50b1f4e0fcb6" name="gabb7eae92aa44ac7b928e50b1f4e0fcb6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NODE_OPTIONS</b>&#160;&#160;&#160;0x0001</td></tr>
<tr class="memdesc:gabb7eae92aa44ac7b928e50b1f4e0fcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options node (following the "singleton" pattern, there is only one options node) <br /></td></tr>
<tr class="separator:gabb7eae92aa44ac7b928e50b1f4e0fcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga857f664c28910030841a774bf1898d0a"><td class="memItemLeft" align="right" valign="top"><a id="ga857f664c28910030841a774bf1898d0a" name="ga857f664c28910030841a774bf1898d0a"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NODE_CAMERA</b>&#160;&#160;&#160;0x0002</td></tr>
<tr class="memdesc:ga857f664c28910030841a774bf1898d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Camera nodes (<code>persp_camera</code>, <code>fisheye_camera</code>, etc) <br /></td></tr>
<tr class="separator:ga857f664c28910030841a774bf1898d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf09bae1a8d33f8394318cd7960984b82"><td class="memItemLeft" align="right" valign="top"><a id="gaf09bae1a8d33f8394318cd7960984b82" name="gaf09bae1a8d33f8394318cd7960984b82"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NODE_LIGHT</b>&#160;&#160;&#160;0x0004</td></tr>
<tr class="memdesc:gaf09bae1a8d33f8394318cd7960984b82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Light source nodes (<code>spot_light</code>, etc) <br /></td></tr>
<tr class="separator:gaf09bae1a8d33f8394318cd7960984b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5da98c230027a66005c322e0b72a94e6"><td class="memItemLeft" align="right" valign="top"><a id="ga5da98c230027a66005c322e0b72a94e6" name="ga5da98c230027a66005c322e0b72a94e6"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NODE_SHAPE</b>&#160;&#160;&#160;0x0008</td></tr>
<tr class="memdesc:ga5da98c230027a66005c322e0b72a94e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Geometry nodes (<code>sphere</code>, <code>polymesh</code>, etc) <br /></td></tr>
<tr class="separator:ga5da98c230027a66005c322e0b72a94e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76527e5c085e5bdda7de726f8f3cba9e"><td class="memItemLeft" align="right" valign="top"><a id="ga76527e5c085e5bdda7de726f8f3cba9e" name="ga76527e5c085e5bdda7de726f8f3cba9e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NODE_SHADER</b>&#160;&#160;&#160;0x0010</td></tr>
<tr class="memdesc:ga76527e5c085e5bdda7de726f8f3cba9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shader nodes (<code>lambert</code>, etc) <br /></td></tr>
<tr class="separator:ga76527e5c085e5bdda7de726f8f3cba9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaeb2a30fa9c732a4d5a04b05b248f6c8"><td class="memItemLeft" align="right" valign="top"><a id="gaaeb2a30fa9c732a4d5a04b05b248f6c8" name="gaaeb2a30fa9c732a4d5a04b05b248f6c8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NODE_OVERRIDE</b>&#160;&#160;&#160;0x0020</td></tr>
<tr class="memdesc:gaaeb2a30fa9c732a4d5a04b05b248f6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">EXPERIMENTAL: override nodes support "delayed parameter overrides" for <code>procedural</code> nodes. <br /></td></tr>
<tr class="separator:gaaeb2a30fa9c732a4d5a04b05b248f6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97634759e5d4dd48e2de3b17016c4ef9"><td class="memItemLeft" align="right" valign="top"><a id="ga97634759e5d4dd48e2de3b17016c4ef9" name="ga97634759e5d4dd48e2de3b17016c4ef9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NODE_DRIVER</b>&#160;&#160;&#160;0x0040</td></tr>
<tr class="memdesc:ga97634759e5d4dd48e2de3b17016c4ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output driver nodes (<code>driver_tiff</code>, etc) <br /></td></tr>
<tr class="separator:ga97634759e5d4dd48e2de3b17016c4ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0c0e7ae078b369318f1a5e93805d7d3"><td class="memItemLeft" align="right" valign="top"><a id="gaa0c0e7ae078b369318f1a5e93805d7d3" name="gaa0c0e7ae078b369318f1a5e93805d7d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NODE_FILTER</b>&#160;&#160;&#160;0x0080</td></tr>
<tr class="memdesc:gaa0c0e7ae078b369318f1a5e93805d7d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pixel sample filter nodes (<code>box_filter</code>, etc. <br /></td></tr>
<tr class="separator:gaa0c0e7ae078b369318f1a5e93805d7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77e61886454ed7ec455943673a760c99"><td class="memItemLeft" align="right" valign="top"><a id="ga77e61886454ed7ec455943673a760c99" name="ga77e61886454ed7ec455943673a760c99"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NODE_COLOR_MANAGER</b>&#160;&#160;&#160;0x0800</td></tr>
<tr class="memdesc:ga77e61886454ed7ec455943673a760c99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Color manager nodes (<code>Syncolor</code>, OCIO, etc) <br /></td></tr>
<tr class="separator:ga77e61886454ed7ec455943673a760c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad257f64d66da24d1d585b257e0777333"><td class="memItemLeft" align="right" valign="top"><a id="gad257f64d66da24d1d585b257e0777333" name="gad257f64d66da24d1d585b257e0777333"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NODE_OPERATOR</b>&#160;&#160;&#160;0x1000</td></tr>
<tr class="memdesc:gad257f64d66da24d1d585b257e0777333"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator plug-in nodes. <br /></td></tr>
<tr class="separator:gad257f64d66da24d1d585b257e0777333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29bc7e471c18a4f059b1e13754edf9c9"><td class="memItemLeft" align="right" valign="top"><a id="ga29bc7e471c18a4f059b1e13754edf9c9" name="ga29bc7e471c18a4f059b1e13754edf9c9"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NODE_IMAGER</b>&#160;&#160;&#160;0x2000</td></tr>
<tr class="memdesc:ga29bc7e471c18a4f059b1e13754edf9c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Imager nodes (<code>imager_tonemap</code>, etc. <br /></td></tr>
<tr class="separator:ga29bc7e471c18a4f059b1e13754edf9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaf029c124baf82592ee04a8a303be9d8"><td class="memItemLeft" align="right" valign="top"><a id="gaaf029c124baf82592ee04a8a303be9d8" name="gaaf029c124baf82592ee04a8a303be9d8"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NODE_ALL</b>&#160;&#160;&#160;0xFFFF</td></tr>
<tr class="memdesc:gaaf029c124baf82592ee04a8a303be9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bitmask including all node types, used by <a class="el" href="group__ai__dotass.html#gad433cf485c3f531251f48e0465779d59" title="Write all nodes in the given universe to an .ass file.">AiASSWrite()</a> <br /></td></tr>
<tr class="separator:gaaf029c124baf82592ee04a8a303be9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader">Derived Node Types</h2></td></tr>
<tr class="memitem:ga3fa599102eb9bb9c2126753885bb2b7c"><td class="memItemLeft" align="right" valign="top"><a id="ga3fa599102eb9bb9c2126753885bb2b7c" name="ga3fa599102eb9bb9c2126753885bb2b7c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NODE_SHAPE_PROCEDURAL</b>&#160;&#160;&#160;0x0100</td></tr>
<tr class="memdesc:ga3fa599102eb9bb9c2126753885bb2b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Procedural shape node. <br /></td></tr>
<tr class="separator:ga3fa599102eb9bb9c2126753885bb2b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f654e55bbedc387437b38a234665ba1"><td class="memItemLeft" align="right" valign="top"><a id="ga8f654e55bbedc387437b38a234665ba1" name="ga8f654e55bbedc387437b38a234665ba1"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NODE_SHAPE_VOLUME</b>&#160;&#160;&#160;0x0200</td></tr>
<tr class="memdesc:ga8f654e55bbedc387437b38a234665ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Volume shape node. <br /></td></tr>
<tr class="separator:ga8f654e55bbedc387437b38a234665ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7394e0e59da0effd9b45662dc2bf8c56"><td class="memItemLeft" align="right" valign="top"><a id="ga7394e0e59da0effd9b45662dc2bf8c56" name="ga7394e0e59da0effd9b45662dc2bf8c56"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>AI_NODE_SHAPE_IMPLICIT</b>&#160;&#160;&#160;0x0400</td></tr>
<tr class="memdesc:ga7394e0e59da0effd9b45662dc2bf8c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implicit shape node. <br /></td></tr>
<tr class="separator:ga7394e0e59da0effd9b45662dc2bf8c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p ><a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> methods. </p>
<p >Arnold <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> class provides information about the structure of a given node type. For a discussion of Arnold's object-oriented system of pluggable nodes, please refer to <a class="el" href="group__ai__nodes.html">AtNode API</a>. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gac7f9366415f0bcf9e695e0bdd0c37468" name="gac7f9366415f0bcf9e695e0bdd0c37468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7f9366415f0bcf9e695e0bdd0c37468">&#9670;&nbsp;</a></span>AiNodeEntryLookUp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> * AiNodeEntryLookUp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up a node entry from a name string. </p>
<p >Search all installed node entries for a given node name. If found, return a pointer to the node entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>input node name (such as "lambert") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a> that matches the input name </dd></dl>

</div>
</div>
<a id="ga74710b24e1206787d037b5b60e98962f" name="ga74710b24e1206787d037b5b60e98962f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74710b24e1206787d037b5b60e98962f">&#9670;&nbsp;</a></span>AiNodeEntryGetName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const char * AiNodeEntryGetName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>name string, or NULL if nentry is NULL </dd></dl>

</div>
</div>
<a id="gaf5689647a4f155fa357f32b1d0907c46" name="gaf5689647a4f155fa357f32b1d0907c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5689647a4f155fa357f32b1d0907c46">&#9670;&nbsp;</a></span>AiNodeEntryGetNameAtString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE <a class="el" href="classAtString.html">AtString</a> AiNodeEntryGetNameAtString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the name of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a> as an <a class="el" href="classAtString.html" title="Arnold String allows for fast string comparisons.">AtString</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classAtString.html" title="Arnold String allows for fast string comparisons.">AtString</a> name string, or NULL <a class="el" href="classAtString.html" title="Arnold String allows for fast string comparisons.">AtString</a> if nentry is NULL </dd></dl>

</div>
</div>
<a id="ga01f300beb73f6b1a19b1e2a0990ce417" name="ga01f300beb73f6b1a19b1e2a0990ce417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01f300beb73f6b1a19b1e2a0990ce417">&#9670;&nbsp;</a></span>AiNodeEntryGetType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE int AiNodeEntryGetType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the type of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type of node (<code>AI_NODE_SHADER</code>, etc), or 0 if nentry is NULL </dd></dl>

</div>
</div>
<a id="gade0b4cad1512a32ae1b6a0e6b60c0047" name="gade0b4cad1512a32ae1b6a0e6b60c0047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade0b4cad1512a32ae1b6a0e6b60c0047">&#9670;&nbsp;</a></span>AiNodeEntryGetTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const char * AiNodeEntryGetTypeName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the type of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a> as a string. </p>
<p >For example, a node of type <code>AI_NODE_LIGHT</code> would return "light"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type string, or NULL if nentry is NULL </dd></dl>

</div>
</div>
<a id="ga27a4a92ffec45e0decb0154904ccba96" name="ga27a4a92ffec45e0decb0154904ccba96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27a4a92ffec45e0decb0154904ccba96">&#9670;&nbsp;</a></span>AiNodeEntryGetDerivedType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE int AiNodeEntryGetDerivedType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the derived type of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>derived type of node (<code>AI_NODE_SHAPE_VOLUME</code>, etc), or 0 if nentry is either NULL or a non-derived type </dd></dl>

</div>
</div>
<a id="ga8447a93f7e0c8ba11838175cfef2af7d" name="ga8447a93f7e0c8ba11838175cfef2af7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8447a93f7e0c8ba11838175cfef2af7d">&#9670;&nbsp;</a></span>AiNodeEntryGetDerivedTypeName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const char * AiNodeEntryGetDerivedTypeName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the derived type of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a> as a string, if applicable. </p>
<p >For example, a node of type <code>AI_NODE_SHAPE_VOLUME</code> would return "volume"</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>type string, or NULL if nentry is NULL or not a derived type </dd></dl>

</div>
</div>
<a id="ga490b4adfc99ef9382fd31ac6faf1d9ed" name="ga490b4adfc99ef9382fd31ac6faf1d9ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga490b4adfc99ef9382fd31ac6faf1d9ed">&#9670;&nbsp;</a></span>AiNodeEntryGetOutputType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE int AiNodeEntryGetOutputType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the output type of the given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>output type (<code>AI_TYPE_RGB</code>, etc) </dd></dl>

</div>
</div>
<a id="ga5e02359d1894eafecd4b1a5e4c9f2658" name="ga5e02359d1894eafecd4b1a5e4c9f2658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5e02359d1894eafecd4b1a5e4c9f2658">&#9670;&nbsp;</a></span>AiNodeEntryGetFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const char * AiNodeEntryGetFilename </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the filename (so/dll path) of an <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string with the path ot the dynamic library where this node was installed from, NULL if this is a built-in node </dd></dl>

</div>
</div>
<a id="gae5be14131550f8c9c207f2a5e56a2b41" name="gae5be14131550f8c9c207f2a5e56a2b41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5be14131550f8c9c207f2a5e56a2b41">&#9670;&nbsp;</a></span>AiNodeEntryGetVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const char * AiNodeEntryGetVersion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the version that this node was linked with. </p>
<p >There are restrictions as to what previously-compiled plug-in nodes can function with a given Arnold library. For example, a plug-in node compiled and linked with Arnold 3.1.x can't be loaded (installed) on Arnold 3.2.x.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string containing the Arnold version that this node was linked with. </dd></dl>

</div>
</div>
<a id="ga9b310c954bc66a54c299e9e98396a18a" name="ga9b310c954bc66a54c299e9e98396a18a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9b310c954bc66a54c299e9e98396a18a">&#9670;&nbsp;</a></span>AiNodeEntryGetCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE int AiNodeEntryGetCount </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of instances of a particular node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of nodes of this type that have been created so far (for example, how many "sphere" nodes exist in memory), or 0 if nentry is NULL </dd></dl>

</div>
</div>
<a id="ga3c5feea77852d4c4ca63ef5c9a06e299" name="ga3c5feea77852d4c4ca63ef5c9a06e299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c5feea77852d4c4ca63ef5c9a06e299">&#9670;&nbsp;</a></span>AiNodeEntryGetNumParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE int AiNodeEntryGetNumParams </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of parameters of a given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of parameters in the node, or 0 if nentry is NULL </dd></dl>

</div>
</div>
<a id="ga66ccecb71a33bb7c757a04afbb7edbe4" name="ga66ccecb71a33bb7c757a04afbb7edbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66ccecb71a33bb7c757a04afbb7edbe4">&#9670;&nbsp;</a></span>AiNodeEntryGetParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const AtParamEntry * AiNodeEntryGetParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the i'th parameter in an <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
    <tr><td class="paramname">i</td><td>parameter index, in 0..num_params-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the i'th parameter entry in this node </dd></dl>

</div>
</div>
<a id="ga0bb08145b24fcc740566cbd7fcd09e6a" name="ga0bb08145b24fcc740566cbd7fcd09e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0bb08145b24fcc740566cbd7fcd09e6a">&#9670;&nbsp;</a></span>AiNodeEntryLookUpParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const AtParamEntry * AiNodeEntryLookUpParameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up a parameter in a node entry from a name string. </p>
<p >Searches the parameter entries of a given node looking for a parameter that matches the name string. If found, returns a pointer to the parameter entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
    <tr><td class="paramname">name</td><td>parameter name that we are looking for (such as "samples") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the AtParamEntry that matches the parameter name, or NULL if either nentry is NULL or the parameter is not found </dd></dl>

</div>
</div>
<a id="ga3684b0531c0ad8bd46787d2523695076" name="ga3684b0531c0ad8bd46787d2523695076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3684b0531c0ad8bd46787d2523695076">&#9670;&nbsp;</a></span>AiNodeEntryGetNumOutputs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE int AiNodeEntryGetNumOutputs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of outputs of a given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of outputs in the node, or 0 if nentry is NULL </dd></dl>

</div>
</div>
<a id="ga39b4f5b9eb2e36b1e2b164b09260b1c8" name="ga39b4f5b9eb2e36b1e2b164b09260b1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39b4f5b9eb2e36b1e2b164b09260b1c8">&#9670;&nbsp;</a></span>AiNodeEntryGetOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const AtParamEntry * AiNodeEntryGetOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the i'th output AtParamEntry in an <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
    <tr><td class="paramname">i</td><td>output index, in 0..num_outputs-1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the i'th output parameter entry in this node </dd></dl>

</div>
</div>
<a id="ga2b7a9204bfce96ee08c0804bcea36bf8" name="ga2b7a9204bfce96ee08c0804bcea36bf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b7a9204bfce96ee08c0804bcea36bf8">&#9670;&nbsp;</a></span>AiNodeEntryLookUpOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_PURE const AtParamEntry * AiNodeEntryLookUpOutput </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAtString.html">AtString</a>&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Look up an output parameter in a node entry from a name string. </p>
<p >Searches the output parameter entries of a given node looking for an output parameter that matches the name string. If found, returns a pointer to its parameter entry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>input node entry </td></tr>
    <tr><td class="paramname">name</td><td>output parameter name that we are looking for (such as "result") </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the AtParamEntry that matches the output parameter name, or NULL if either nentry is NULL or the output parameter is not found </dd></dl>

</div>
</div>
<a id="gad75672e2b0955b64c9b6f11b409643b3" name="gad75672e2b0955b64c9b6f11b409643b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad75672e2b0955b64c9b6f11b409643b3">&#9670;&nbsp;</a></span>AiNodeEntryGetParamIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AtParamIterator * AiNodeEntryGetParamIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a new AtParamIterator for this node entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>node entry whose parameters will be iterated over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator over all built-in parameters on this node entry </dd></dl>

</div>
</div>
<a id="gad10f698b43b1ad4c626318803d02f71d" name="gad10f698b43b1ad4c626318803d02f71d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad10f698b43b1ad4c626318803d02f71d">&#9670;&nbsp;</a></span>AiNodeEntryGetMetaDataIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AtMetaDataIterator * AiNodeEntryGetMetaDataIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtNodeEntry.html">AtNodeEntry</a> *&#160;</td>
          <td class="paramname"><em>nentry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates and returns a new AtMetaDataIterator for this node entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nentry</td><td>node entry whose metadata will be iterated over </td></tr>
    <tr><td class="paramname">param</td><td>selects a specific parameter to get its metadata or NULL for node metadata </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator over metadata on this node entry </dd></dl>

</div>
</div>
<a id="ga000f6845aff3227c1091cf979e1666ce" name="ga000f6845aff3227c1091cf979e1666ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga000f6845aff3227c1091cf979e1666ce">&#9670;&nbsp;</a></span>AiNodeEntryInstall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeEntryInstall </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>output_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtNodeMethods.html">AtNodeMethods</a> *&#160;</td>
          <td class="paramname"><em>methods</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install a new node in the system. </p>
<p >An Arnold-based app can use this function to extend the renderer with custom types of nodes, such as new shaders or cameras. The user must provide the node type, name, and methods. Successive calls to <a class="el" href="group__ai__nodes.html#ga0ec954bbf54e8e47e0f3706c49a174fe" title="Create a fresh instantiation of a node in a specific Arnold universe.">AiNode()</a> can create nodes of this type.</p>
<p >Examples: </p><div class="fragment"><div class="line"><a class="code hl_function" href="group__ai__node__entry.html#ga000f6845aff3227c1091cf979e1666ce">AiNodeEntryInstall</a>(<a class="code hl_define" href="group__ai__node__entry.html#ga5da98c230027a66005c322e0b72a94e6">AI_NODE_SHAPE</a>, <a class="code hl_define" href="group__ai__params.html#ga449b89ef3593a6dacaa8e36447cee1af">AI_TYPE_UNDEFINED</a>, <span class="stringliteral">&quot;sphere&quot;</span>, <span class="stringliteral">&quot;&lt;built-in&gt;&quot;</span>, SphMethods, <a class="code hl_define" href="group__ai__version.html#ga0fa6df40e275fee5979261866f55d662">AI_VERSION</a>);</div>
<div class="line"><a class="code hl_function" href="group__ai__node__entry.html#ga000f6845aff3227c1091cf979e1666ce">AiNodeEntryInstall</a>(<a class="code hl_define" href="group__ai__node__entry.html#ga76527e5c085e5bdda7de726f8f3cba9e">AI_NODE_SHADER</a>, <a class="code hl_define" href="group__ai__params.html#ga24544bb67a6de898f58e9ee2b50ccfed">AI_TYPE_FLOAT</a>, <span class="stringliteral">&quot;fBm_noise&quot;</span>, <span class="stringliteral">&quot;./shaders/fBm_noise.so&quot;</span>, fBmMethods, <a class="code hl_define" href="group__ai__version.html#ga0fa6df40e275fee5979261866f55d662">AI_VERSION</a>);</div>
<div class="ttc" id="agroup__ai__node__entry_html_ga000f6845aff3227c1091cf979e1666ce"><div class="ttname"><a href="group__ai__node__entry.html#ga000f6845aff3227c1091cf979e1666ce">AiNodeEntryInstall</a></div><div class="ttdeci">AI_API void AiNodeEntryInstall(int type, uint8_t output_type, const char *name, const char *filename, const AtNodeMethods *methods, const char *version)</div><div class="ttdoc">Install a new node in the system.</div><div class="ttdef"><b>Definition:</b> ai_nodeentry.cpp:308</div></div>
<div class="ttc" id="agroup__ai__node__entry_html_ga5da98c230027a66005c322e0b72a94e6"><div class="ttname"><a href="group__ai__node__entry.html#ga5da98c230027a66005c322e0b72a94e6">AI_NODE_SHAPE</a></div><div class="ttdeci">#define AI_NODE_SHAPE</div><div class="ttdoc">Geometry nodes (sphere, polymesh, etc)</div><div class="ttdef"><b>Definition:</b> ai_node_entry.h:41</div></div>
<div class="ttc" id="agroup__ai__node__entry_html_ga76527e5c085e5bdda7de726f8f3cba9e"><div class="ttname"><a href="group__ai__node__entry.html#ga76527e5c085e5bdda7de726f8f3cba9e">AI_NODE_SHADER</a></div><div class="ttdeci">#define AI_NODE_SHADER</div><div class="ttdoc">Shader nodes (lambert, etc)</div><div class="ttdef"><b>Definition:</b> ai_node_entry.h:42</div></div>
<div class="ttc" id="agroup__ai__params_html_ga24544bb67a6de898f58e9ee2b50ccfed"><div class="ttname"><a href="group__ai__params.html#ga24544bb67a6de898f58e9ee2b50ccfed">AI_TYPE_FLOAT</a></div><div class="ttdeci">#define AI_TYPE_FLOAT</div><div class="ttdoc">float (Single-precision floating point number)</div><div class="ttdef"><b>Definition:</b> ai_params.h:74</div></div>
<div class="ttc" id="agroup__ai__params_html_ga449b89ef3593a6dacaa8e36447cee1af"><div class="ttname"><a href="group__ai__params.html#ga449b89ef3593a6dacaa8e36447cee1af">AI_TYPE_UNDEFINED</a></div><div class="ttdeci">#define AI_TYPE_UNDEFINED</div><div class="ttdoc">Undefined, you should never encounter a parameter of this type.</div><div class="ttdef"><b>Definition:</b> ai_params.h:88</div></div>
<div class="ttc" id="agroup__ai__version_html_ga0fa6df40e275fee5979261866f55d662"><div class="ttname"><a href="group__ai__version.html#ga0fa6df40e275fee5979261866f55d662">AI_VERSION</a></div><div class="ttdeci">#define AI_VERSION</div><div class="ttdoc">Full Arnold version as string.</div><div class="ttdef"><b>Definition:</b> ai_version.h:58</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>type of node (<code>AI_NODE_CAMERA</code>, <code>AI_NODE_SHADER</code>, etc) </td></tr>
    <tr><td class="paramname">output_type</td><td>for shader nodes, which can link their output to the input of another shader, this is the output type (<code>AI_TYPE_RGB</code>, etc) </td></tr>
    <tr><td class="paramname">name</td><td>name string of the newly created node type </td></tr>
    <tr><td class="paramname">filename</td><td>string identifier that hints at how this node was created, usually the path of the dynamic library where it was loaded from but, in general, it should be set to whatever makes sense for the app that's installing the node </td></tr>
    <tr><td class="paramname">methods</td><td>pointer to the node methods </td></tr>
    <tr><td class="paramname">version</td><td>Arnold version string that this node is linked with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6abc6229eb77d0096810f4fee1befcd2" name="ga6abc6229eb77d0096810f4fee1befcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6abc6229eb77d0096810f4fee1befcd2">&#9670;&nbsp;</a></span>AiNodeEntryUninstall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiNodeEntryUninstall </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Uninstall a node from the system. </p>
<p >Remove the node with the given name from the system. Successive calls to <a class="el" href="group__ai__nodes.html#ga0ec954bbf54e8e47e0f3706c49a174fe" title="Create a fresh instantiation of a node in a specific Arnold universe.">AiNode()</a> using this node name will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>name of the node to be removed from the system </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga305c25e73f44db3aec114b5af9e996b1" name="ga305c25e73f44db3aec114b5af9e996b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga305c25e73f44db3aec114b5af9e996b1">&#9670;&nbsp;</a></span>AiParamIteratorDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiParamIteratorDestroy </td>
          <td>(</td>
          <td class="paramtype">AtParamIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a param iterator when it is no longer needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>param iterator that will be deallocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6d4e2ac734015e40d9954f78c0469439" name="ga6d4e2ac734015e40d9954f78c0469439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d4e2ac734015e40d9954f78c0469439">&#9670;&nbsp;</a></span>AiParamIteratorGetNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API const AtParamEntry * AiParamIteratorGetNext </td>
          <td>(</td>
          <td class="paramtype">AtParamIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current param entry and points param iterator to the next one. </p>
<p >This function is designed to be used inside a loop, as illustrated by the following example, which prints all the built-in parameters of a given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>:</p>
<div class="fragment"><div class="line">AtParamIterator *iter = <a class="code hl_function" href="group__ai__node__entry.html#gad75672e2b0955b64c9b6f11b409643b3">AiNodeEntryGetParamIterator</a>(nentry);</div>
<div class="line"><span class="keywordflow">while</span> (!<a class="code hl_function" href="group__ai__node__entry.html#gac2d3ab8b20294363c89fd694596de145">AiParamIteratorFinished</a>(iter))</div>
<div class="line">{</div>
<div class="line">   AtParamEntry *pentry = <a class="code hl_function" href="group__ai__node__entry.html#ga6d4e2ac734015e40d9954f78c0469439">AiParamIteratorGetNext</a>(iter);</div>
<div class="line">   printf(<span class="stringliteral">&quot;%s\n&quot;</span>, <a class="code hl_function" href="group__ai__params.html#ga933cd2185ed92d9532590cda45aad795">AiParamGetName</a>(pentry));</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__ai__node__entry.html#ga305c25e73f44db3aec114b5af9e996b1">AiParamIteratorDestroy</a>(iter);</div>
<div class="ttc" id="agroup__ai__node__entry_html_ga305c25e73f44db3aec114b5af9e996b1"><div class="ttname"><a href="group__ai__node__entry.html#ga305c25e73f44db3aec114b5af9e996b1">AiParamIteratorDestroy</a></div><div class="ttdeci">AI_API void AiParamIteratorDestroy(AtParamIterator *iter)</div><div class="ttdoc">Destroys a param iterator when it is no longer needed.</div><div class="ttdef"><b>Definition:</b> ai_nodeentry.cpp:351</div></div>
<div class="ttc" id="agroup__ai__node__entry_html_ga6d4e2ac734015e40d9954f78c0469439"><div class="ttname"><a href="group__ai__node__entry.html#ga6d4e2ac734015e40d9954f78c0469439">AiParamIteratorGetNext</a></div><div class="ttdeci">AI_API const AtParamEntry * AiParamIteratorGetNext(AtParamIterator *iter)</div><div class="ttdoc">Returns current param entry and points param iterator to the next one.</div><div class="ttdef"><b>Definition:</b> ai_nodeentry.cpp:377</div></div>
<div class="ttc" id="agroup__ai__node__entry_html_gac2d3ab8b20294363c89fd694596de145"><div class="ttname"><a href="group__ai__node__entry.html#gac2d3ab8b20294363c89fd694596de145">AiParamIteratorFinished</a></div><div class="ttdeci">AI_API bool AiParamIteratorFinished(const AtParamIterator *iter)</div><div class="ttdoc">Returns true if there are no more parameters to iterate over.</div><div class="ttdef"><b>Definition:</b> ai_nodeentry.cpp:391</div></div>
<div class="ttc" id="agroup__ai__node__entry_html_gad75672e2b0955b64c9b6f11b409643b3"><div class="ttname"><a href="group__ai__node__entry.html#gad75672e2b0955b64c9b6f11b409643b3">AiNodeEntryGetParamIterator</a></div><div class="ttdeci">AI_API AtParamIterator * AiNodeEntryGetParamIterator(const AtNodeEntry *nentry)</div><div class="ttdoc">Creates and returns a new AtParamIterator for this node entry.</div><div class="ttdef"><b>Definition:</b> ai_nodeentry.cpp:341</div></div>
<div class="ttc" id="agroup__ai__params_html_ga933cd2185ed92d9532590cda45aad795"><div class="ttname"><a href="group__ai__params.html#ga933cd2185ed92d9532590cda45aad795">AiParamGetName</a></div><div class="ttdeci">AI_API AI_PURE AtString AiParamGetName(const AtParamEntry *pentry)</div><div class="ttdoc">Return the name of a given parameter.</div><div class="ttdef"><b>Definition:</b> ai_paramentry.cpp:86</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a param iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current param entry pointed by the iterator, or <code>NULL</code> if there are no more parameters to iterate over </dd></dl>

</div>
</div>
<a id="gac2d3ab8b20294363c89fd694596de145" name="gac2d3ab8b20294363c89fd694596de145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2d3ab8b20294363c89fd694596de145">&#9670;&nbsp;</a></span>AiParamIteratorFinished()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiParamIteratorFinished </td>
          <td>(</td>
          <td class="paramtype">const AtParamIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there are no more parameters to iterate over. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a param iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the param iterator has moved past the last parameter </dd></dl>

</div>
</div>
<a id="gafa165f4d801d854b7ef0bc757f96fe16" name="gafa165f4d801d854b7ef0bc757f96fe16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa165f4d801d854b7ef0bc757f96fe16">&#9670;&nbsp;</a></span>AiMetaDataIteratorDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API void AiMetaDataIteratorDestroy </td>
          <td>(</td>
          <td class="paramtype">AtMetaDataIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a metadata iterator when it is no longer needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>metadata iterator that will be deallocated </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf1fe52c23c2935e2b46f1e47387073a7" name="gaf1fe52c23c2935e2b46f1e47387073a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1fe52c23c2935e2b46f1e47387073a7">&#9670;&nbsp;</a></span>AiMetaDataIteratorGetNext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API const <a class="el" href="structAtMetaDataEntry.html">AtMetaDataEntry</a> * AiMetaDataIteratorGetNext </td>
          <td>(</td>
          <td class="paramtype">AtMetaDataIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns current metadata entry and points metadata iterator to the next one. </p>
<p >This function is designed to be used inside a loop, as illustrated by the following example, which prints all the metadata of a given <a class="el" href="structAtNodeEntry.html" title="This represents a node type in Arnold.">AtNodeEntry</a>:</p>
<div class="fragment"><div class="line">AtMetaDataIterator *iter = <a class="code hl_function" href="group__ai__node__entry.html#gad10f698b43b1ad4c626318803d02f71d">AiNodeEntryGetMetaDataIterator</a>(nentry);</div>
<div class="line"><span class="keywordflow">while</span> (!<a class="code hl_function" href="group__ai__node__entry.html#ga2ed3ad36805c2a2b850c9e776193a0de">AiMetaDataIteratorFinished</a>(iter))</div>
<div class="line">{</div>
<div class="line">   <span class="keyword">const</span> <a class="code hl_struct" href="structAtMetaDataEntry.html">AtMetaDataEntry</a> *entry = <a class="code hl_function" href="group__ai__node__entry.html#gaf1fe52c23c2935e2b46f1e47387073a7">AiMetaDataIteratorGetNext</a>(iter);</div>
<div class="line">   printf(<span class="stringliteral">&quot;%s\n&quot;</span>, entry-&gt;name);</div>
<div class="line">}</div>
<div class="line"><a class="code hl_function" href="group__ai__node__entry.html#gafa165f4d801d854b7ef0bc757f96fe16">AiMetaDataIteratorDestroy</a>(iter);</div>
<div class="ttc" id="agroup__ai__node__entry_html_ga2ed3ad36805c2a2b850c9e776193a0de"><div class="ttname"><a href="group__ai__node__entry.html#ga2ed3ad36805c2a2b850c9e776193a0de">AiMetaDataIteratorFinished</a></div><div class="ttdeci">AI_API bool AiMetaDataIteratorFinished(const AtMetaDataIterator *iter)</div><div class="ttdoc">Returns true if there is no more metadata to iterate over.</div><div class="ttdef"><b>Definition:</b> ai_metadata.cpp:176</div></div>
<div class="ttc" id="agroup__ai__node__entry_html_gad10f698b43b1ad4c626318803d02f71d"><div class="ttname"><a href="group__ai__node__entry.html#gad10f698b43b1ad4c626318803d02f71d">AiNodeEntryGetMetaDataIterator</a></div><div class="ttdeci">AI_API AtMetaDataIterator * AiNodeEntryGetMetaDataIterator(const AtNodeEntry *nentry, const char *param=NULL)</div><div class="ttdoc">Creates and returns a new AtMetaDataIterator for this node entry.</div><div class="ttdef"><b>Definition:</b> ai_nodeentry.cpp:403</div></div>
<div class="ttc" id="agroup__ai__node__entry_html_gaf1fe52c23c2935e2b46f1e47387073a7"><div class="ttname"><a href="group__ai__node__entry.html#gaf1fe52c23c2935e2b46f1e47387073a7">AiMetaDataIteratorGetNext</a></div><div class="ttdeci">AI_API const AtMetaDataEntry * AiMetaDataIteratorGetNext(AtMetaDataIterator *iter)</div><div class="ttdoc">Returns current metadata entry and points metadata iterator to the next one.</div><div class="ttdef"><b>Definition:</b> ai_metadata.cpp:165</div></div>
<div class="ttc" id="agroup__ai__node__entry_html_gafa165f4d801d854b7ef0bc757f96fe16"><div class="ttname"><a href="group__ai__node__entry.html#gafa165f4d801d854b7ef0bc757f96fe16">AiMetaDataIteratorDestroy</a></div><div class="ttdeci">AI_API void AiMetaDataIteratorDestroy(AtMetaDataIterator *iter)</div><div class="ttdoc">Destroys a metadata iterator when it is no longer needed.</div><div class="ttdef"><b>Definition:</b> ai_metadata.cpp:139</div></div>
<div class="ttc" id="astructAtMetaDataEntry_html"><div class="ttname"><a href="structAtMetaDataEntry.html">AtMetaDataEntry</a></div><div class="ttdef"><b>Definition:</b> ai_node_entry.h:92</div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a metadata iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current metadata entry pointed by the iterator, or <code>NULL</code> if there is no more metadata to iterate over </dd></dl>

</div>
</div>
<a id="ga2ed3ad36805c2a2b850c9e776193a0de" name="ga2ed3ad36805c2a2b850c9e776193a0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ed3ad36805c2a2b850c9e776193a0de">&#9670;&nbsp;</a></span>AiMetaDataIteratorFinished()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API bool AiMetaDataIteratorFinished </td>
          <td>(</td>
          <td class="paramtype">const AtMetaDataIterator *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if there is no more metadata to iterate over. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>a metadata iterator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the metadata iterator has moved past the last entry </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2023 Autodesk, Inc. &middot All rights reserved &middot <a href="http://www.arnoldrenderer.com/"><font size=-2 color=#C9C9C9>www.arnoldrenderer.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
