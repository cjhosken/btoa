<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<title>Arnold 7.3.5.0 API Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Shader Closure API</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="structAtClosure.html">AtClosure</a> creation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga6d3cef94661cf0c87e7163a337a6c32d"><td class="memItemLeft" align="right" valign="top"><a id="ga6d3cef94661cf0c87e7163a337a6c32d" name="ga6d3cef94661cf0c87e7163a337a6c32d"></a>enum class &#160;</td><td class="memItemRight" valign="bottom"><b>AtRandomWalkVersion</b> { <b>v1</b> = 1
, <b>v2</b>
, <b>v3</b>
 }</td></tr>
<tr class="separator:ga6d3cef94661cf0c87e7163a337a6c32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga8598077746bb1f205cf2e800831129dd"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__closure.html#ga8598077746bb1f205cf2e800831129dd">AiClosureEmpiricalBSSRDF</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;weight, const <a class="el" href="structAtVector.html">AtVector</a> &amp;mfp, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;albedo)</td></tr>
<tr class="memdesc:ga8598077746bb1f205cf2e800831129dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create BSSRDF closure for subsurface scattering in surface shaders.  <a href="group__ai__shader__closure.html#ga8598077746bb1f205cf2e800831129dd">More...</a><br /></td></tr>
<tr class="separator:ga8598077746bb1f205cf2e800831129dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5064684004c98deebce314a5013da08"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__closure.html#gac5064684004c98deebce314a5013da08">AiClosureRandomWalkBSSRDF</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const AtRandomWalkVersion &amp;version, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;weight, const <a class="el" href="structAtVector.html">AtVector</a> &amp;mfp, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;albedo, float g=0.0f)</td></tr>
<tr class="memdesc:gac5064684004c98deebce314a5013da08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create BSSRDF closure for random walk subsurface scattering in surface shaders.  <a href="group__ai__shader__closure.html#gac5064684004c98deebce314a5013da08">More...</a><br /></td></tr>
<tr class="separator:gac5064684004c98deebce314a5013da08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7836874331ba72a6a99008a08828887"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__closure.html#gac7836874331ba72a6a99008a08828887">AiClosureBSSRDFSetDirectIndirect</a> (<a class="el" href="structAtClosure.html">AtClosure</a> closure, float weight_direct, float weight_indirect)</td></tr>
<tr class="memdesc:gac7836874331ba72a6a99008a08828887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the BSSRDF closure direct and indirect light contribution weights.  <a href="group__ai__shader__closure.html#gac7836874331ba72a6a99008a08828887">More...</a><br /></td></tr>
<tr class="separator:gac7836874331ba72a6a99008a08828887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92a52070cd5e4edaa62adc31bb1a8cb9"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__closure.html#ga92a52070cd5e4edaa62adc31bb1a8cb9">AiClosureEmission</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;weight)</td></tr>
<tr class="memdesc:ga92a52070cd5e4edaa62adc31bb1a8cb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create emission closure for surface shaders.  <a href="group__ai__shader__closure.html#ga92a52070cd5e4edaa62adc31bb1a8cb9">More...</a><br /></td></tr>
<tr class="separator:ga92a52070cd5e4edaa62adc31bb1a8cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a9c01b6724dd88e840038e0fa003566"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__closure.html#ga7a9c01b6724dd88e840038e0fa003566">AiClosureTransparent</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;weight=AI_RGB_WHITE, const <a class="el" href="structAtClosureList.html">AtClosureList</a> interior=NULL, int32_t importance=0)</td></tr>
<tr class="memdesc:ga7a9c01b6724dd88e840038e0fa003566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create transparent closure for surface shaders.  <a href="group__ai__shader__closure.html#ga7a9c01b6724dd88e840038e0fa003566">More...</a><br /></td></tr>
<tr class="separator:ga7a9c01b6724dd88e840038e0fa003566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga194f353a25816ee70b5e6e1984b6ca1b"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__closure.html#ga194f353a25816ee70b5e6e1984b6ca1b">AiClosureMatte</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;weight=AI_RGB_WHITE)</td></tr>
<tr class="memdesc:ga194f353a25816ee70b5e6e1984b6ca1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create matte closure for surface shaders.  <a href="group__ai__shader__closure.html#ga194f353a25816ee70b5e6e1984b6ca1b">More...</a><br /></td></tr>
<tr class="separator:ga194f353a25816ee70b5e6e1984b6ca1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99539811a1edc45537ef867cbf93f157"><td class="memItemLeft" align="right" valign="top">AI_API <a class="el" href="structAtClosure.html">AtClosure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__closure.html#ga99539811a1edc45537ef867cbf93f157">AiClosureBackground</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;weight=AI_RGB_WHITE)</td></tr>
<tr class="memdesc:ga99539811a1edc45537ef867cbf93f157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create background closure for background surface shaders.  <a href="group__ai__shader__closure.html#ga99539811a1edc45537ef867cbf93f157">More...</a><br /></td></tr>
<tr class="separator:ga99539811a1edc45537ef867cbf93f157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5915559e8a125d4cf4376f43583b2a3"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__closure.html#gac5915559e8a125d4cf4376f43583b2a3">AiClosureVolumeAbsorption</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;weight)</td></tr>
<tr class="memdesc:gac5915559e8a125d4cf4376f43583b2a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create volume absorption closure, for volume shaders.  <a href="group__ai__shader__closure.html#gac5915559e8a125d4cf4376f43583b2a3">More...</a><br /></td></tr>
<tr class="separator:gac5915559e8a125d4cf4376f43583b2a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5ff07828789e0d6b51b8069a75aa842f"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__closure.html#ga5ff07828789e0d6b51b8069a75aa842f">AiClosureVolumeEmission</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;weight)</td></tr>
<tr class="memdesc:ga5ff07828789e0d6b51b8069a75aa842f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create volume emission closure, for volume shaders.  <a href="group__ai__shader__closure.html#ga5ff07828789e0d6b51b8069a75aa842f">More...</a><br /></td></tr>
<tr class="separator:ga5ff07828789e0d6b51b8069a75aa842f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf70e8d1f6acc3628d3217d3884ad9298"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__closure.html#gaf70e8d1f6acc3628d3217d3884ad9298">AiClosureVolumeHenyeyGreenstein</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;absorption, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;scattering, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;emission, float g=0.f)</td></tr>
<tr class="memdesc:gaf70e8d1f6acc3628d3217d3884ad9298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create Henyey-Greenstein volume scattering closure, for volume shaders.  <a href="group__ai__shader__closure.html#gaf70e8d1f6acc3628d3217d3884ad9298">More...</a><br /></td></tr>
<tr class="separator:gaf70e8d1f6acc3628d3217d3884ad9298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga227911391a3a06154875f38400248e79"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__closure.html#ga227911391a3a06154875f38400248e79">AiClosureVolumeDoubleHenyeyGreenstein</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;absorption, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;scattering, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;emission, float g=0.f, float g2=0.f, float w2=0.f)</td></tr>
<tr class="memdesc:ga227911391a3a06154875f38400248e79"><td class="mdescLeft">&#160;</td><td class="mdescRight">This creates a linear mix of two Henyey-Greenstein phase function lobes, of the form:  <a href="group__ai__shader__closure.html#ga227911391a3a06154875f38400248e79">More...</a><br /></td></tr>
<tr class="separator:ga227911391a3a06154875f38400248e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4f6ebf71513a1a3b32f54b745c33ef9"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__closure.html#gad4f6ebf71513a1a3b32f54b745c33ef9">AiClosureVolumeMatte</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;weight)</td></tr>
<tr class="memdesc:gad4f6ebf71513a1a3b32f54b745c33ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create volume matte closure, for volume shaders.  <a href="group__ai__shader__closure.html#gad4f6ebf71513a1a3b32f54b745c33ef9">More...</a><br /></td></tr>
<tr class="separator:gad4f6ebf71513a1a3b32f54b745c33ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23d1565d2f66561f65582ddf6b9c89d3"><td class="memItemLeft" align="right" valign="top">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__ai__shader__closure.html#ga23d1565d2f66561f65582ddf6b9c89d3">AiClosureVolumeAtmosphere</a> (const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *sg, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;emission, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;transparent, const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;matte)</td></tr>
<tr class="memdesc:ga23d1565d2f66561f65582ddf6b9c89d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create volume atmosphere closure, for legacy atmosphere shaders.  <a href="group__ai__shader__closure.html#ga23d1565d2f66561f65582ddf6b9c89d3">More...</a><br /></td></tr>
<tr class="separator:ga23d1565d2f66561f65582ddf6b9c89d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p ><a class="el" href="structAtClosure.html">AtClosure</a> creation. </p>
<p >Shaders can return these instead of final colors.</p>
<p >Closures describe the way surfaces and volumes scatter light, leaving the lights loops and integration to Arnold.</p>
<p >For creating BSDF closures, an <code>AtBSDF</code> can be wrapped in a closure: </p><div class="fragment"><div class="line">AtBSDF *bsdf = <a class="code hl_function" href="group__ai__shader__bsdf.html#ga8e9008822c5ee401df46884aca89430b">AiOrenNayarBSDF</a>(sg, sg-&gt;Nf);</div>
<div class="line">sg-&gt;out.CLOSURE() = <a class="code hl_struct" href="structAtClosure.html">AtClosure</a>(diffuse_color, bsdf);</div>
<div class="ttc" id="agroup__ai__shader__bsdf_html_ga8e9008822c5ee401df46884aca89430b"><div class="ttname"><a href="group__ai__shader__bsdf.html#ga8e9008822c5ee401df46884aca89430b">AiOrenNayarBSDF</a></div><div class="ttdeci">AI_API AI_DEPRECATED AI_DEVICE AtBSDF * AiOrenNayarBSDF(const AtShaderGlobals *sg, const AtRGB &amp;weight, const AtVector &amp;N, float r=0.0f, bool transmission=false, const AtString label=AtString())</div><div class="ttdoc">Create Oren-Nayar BSDF (classic &quot;qualitative&quot; model).</div><div class="ttdef"><b>Definition:</b> ai_shader_bsdf.cpp:165</div></div>
<div class="ttc" id="astructAtClosure_html"><div class="ttname"><a href="structAtClosure.html">AtClosure</a></div><div class="ttdef"><b>Definition:</b> ai_closure.h:61</div></div>
</div><!-- fragment --> <h2 class="groupheader">Function Documentation</h2>
<a id="ga8598077746bb1f205cf2e800831129dd" name="ga8598077746bb1f205cf2e800831129dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8598077746bb1f205cf2e800831129dd">&#9670;&nbsp;</a></span>AiClosureEmpiricalBSSRDF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a> AiClosureEmpiricalBSSRDF </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>mfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>albedo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create BSSRDF closure for subsurface scattering in surface shaders. </p>
<p >This is a diffusion BSSRDF model empirically fitted to match brute-force Monte Carlo scattering. The BSSRDF accounts for both single and multiple scattering. Note that Fresnel or other layer or mixing weights must be provided separately from the albedo, as the albedo affects the shape of the BSSRDF profile.</p>
<dl class="section see"><dt>See also</dt><dd><a href="http://graphics.pixar.com/library/ApproxBSSRDF/">http://graphics.pixar.com/library/ApproxBSSRDF/</a></dd></dl>
<p>BSSRDF sampling quality is controlled by the <code>GI_sss_samples</code> render option.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals </td></tr>
    <tr><td class="paramname">weight</td><td>RGB weights for mixing profiles or applying fresnel </td></tr>
    <tr><td class="paramname">mfp</td><td>per RGB wavelength mean free path lengths (<em>mfp = 1/sigma<sub>t</sub>' = 1/(sigma<sub>s</sub>' + sigma<sub>a</sub>)</em>) </td></tr>
    <tr><td class="paramname">albedo</td><td>diffuse reflectivity </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BSSRDF closure </dd></dl>

</div>
</div>
<a id="gac5064684004c98deebce314a5013da08" name="gac5064684004c98deebce314a5013da08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5064684004c98deebce314a5013da08">&#9670;&nbsp;</a></span>AiClosureRandomWalkBSSRDF()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a> AiClosureRandomWalkBSSRDF </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AtRandomWalkVersion &amp;&#160;</td>
          <td class="paramname"><em>version</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtVector.html">AtVector</a> &amp;&#160;</td>
          <td class="paramname"><em>mfp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>albedo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create BSSRDF closure for random walk subsurface scattering in surface shaders. </p>
<p >Note that Fresnel or other layer or mixing weights must be provided separately from the albedo, as the albedo affects the shape of the BSSRDF profile.</p>
<p >BSSRDF sampling quality is controlled by the <code>GI_sss_samples</code> render option.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals </td></tr>
    <tr><td class="paramname">weight</td><td>RGB weights for mixing profiles or applying fresnel </td></tr>
    <tr><td class="paramname">mfp</td><td>per RGB wavelength mean free path lengths (<em>mfp = 1/sigma<sub>t</sub>' = 1/(sigma<sub>s</sub>' + sigma<sub>a</sub>)</em>) </td></tr>
    <tr><td class="paramname">albedo</td><td>diffuse reflectivity </td></tr>
    <tr><td class="paramname">g</td><td>Henyey-Greenstein anisotropy parameter for anisotropic scattering </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BSSRDF closure </dd></dl>

</div>
</div>
<a id="gac7836874331ba72a6a99008a08828887" name="gac7836874331ba72a6a99008a08828887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7836874331ba72a6a99008a08828887">&#9670;&nbsp;</a></span>AiClosureBSSRDFSetDirectIndirect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE void AiClosureBSSRDFSetDirectIndirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structAtClosure.html">AtClosure</a>&#160;</td>
          <td class="paramname"><em>closure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>weight_direct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>weight_indirect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the BSSRDF closure direct and indirect light contribution weights. </p>
<p >For physically correct rendering, these must be set to the default 1.0, however for artistic control the direct and indirect light contributions can be scaled independently.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">closure</td><td>BSSRDF closure </td></tr>
    <tr><td class="paramname">weight_direct</td><td>Direct light weight </td></tr>
    <tr><td class="paramname">weight_indirect</td><td>Indirect light weight </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga92a52070cd5e4edaa62adc31bb1a8cb9" name="ga92a52070cd5e4edaa62adc31bb1a8cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92a52070cd5e4edaa62adc31bb1a8cb9">&#9670;&nbsp;</a></span>AiClosureEmission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a> AiClosureEmission </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create emission closure for surface shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals </td></tr>
    <tr><td class="paramname">weight</td><td>emission radiance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>emission closure </dd></dl>

</div>
</div>
<a id="ga7a9c01b6724dd88e840038e0fa003566" name="ga7a9c01b6724dd88e840038e0fa003566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a9c01b6724dd88e840038e0fa003566">&#9670;&nbsp;</a></span>AiClosureTransparent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a> AiClosureTransparent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtClosureList.html">AtClosureList</a>&#160;</td>
          <td class="paramname"><em>interior</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>importance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create transparent closure for surface shaders. </p>
<p >When making a surface transparent, other surface closures should have the opacity multiplied in, so that the total weight of all closures does not exceed 1 and energy is conserved. Mixing with other closures can be done as follows:</p>
<div class="fragment"><div class="line">closures *= opacity;</div>
<div class="line">closures.add(<a class="code hl_function" href="group__ai__shader__closure.html#ga7a9c01b6724dd88e840038e0fa003566">AiClosureTransparent</a>(sg, 1 - opacity));</div>
<div class="ttc" id="agroup__ai__shader__closure_html_ga7a9c01b6724dd88e840038e0fa003566"><div class="ttname"><a href="group__ai__shader__closure.html#ga7a9c01b6724dd88e840038e0fa003566">AiClosureTransparent</a></div><div class="ttdeci">AI_API AI_DEVICE AtClosure AiClosureTransparent(const AtShaderGlobals *sg, const AtRGB &amp;weight=AI_RGB_WHITE, const AtClosureList interior=NULL, int32_t importance=0)</div><div class="ttdoc">Create transparent closure for surface shaders.</div><div class="ttdef"><b>Definition:</b> ai_shader_closure.cpp:229</div></div>
</div><!-- fragment --><p >Objects must have the opaque parameter off to render transparency.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals </td></tr>
    <tr><td class="paramname">weight</td><td>transparency </td></tr>
    <tr><td class="paramname">interior</td><td>optional volume closures for interior of the object </td></tr>
    <tr><td class="paramname">importance</td><td>used to resolve overlaps </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>transparent closure </dd></dl>

</div>
</div>
<a id="ga194f353a25816ee70b5e6e1984b6ca1b" name="ga194f353a25816ee70b5e6e1984b6ca1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga194f353a25816ee70b5e6e1984b6ca1b">&#9670;&nbsp;</a></span>AiClosureMatte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a> AiClosureMatte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create matte closure for surface shaders. </p>
<p >The matte closure creates a holdout effect by rendering alphas as zero. This works like the matte parameter on shapes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals </td></tr>
    <tr><td class="paramname">weight</td><td>matte transparency </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>matte closure </dd></dl>

</div>
</div>
<a id="ga99539811a1edc45537ef867cbf93f157" name="ga99539811a1edc45537ef867cbf93f157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99539811a1edc45537ef867cbf93f157">&#9670;&nbsp;</a></span>AiClosureBackground()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API <a class="el" href="structAtClosure.html">AtClosure</a> AiClosureBackground </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create background closure for background surface shaders. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals </td></tr>
    <tr><td class="paramname">weight</td><td>emission radiance </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>background closure </dd></dl>

</div>
</div>
<a id="gac5915559e8a125d4cf4376f43583b2a3" name="gac5915559e8a125d4cf4376f43583b2a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5915559e8a125d4cf4376f43583b2a3">&#9670;&nbsp;</a></span>AiClosureVolumeAbsorption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a> AiClosureVolumeAbsorption </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create volume absorption closure, for volume shaders. </p>
<p >The closure weight is the absorption coefficient. This coefficient is the rate at which the volume absorbs light that is traveling along the given direction at the given point. Any light that traverses a volume with a given absoprtion coefficient will be attenuated at a rate of:</p>
<p >attenuation = expf(-(scattering_coefficient + absorption_coefficient) * distance_travelled)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals that the volume shader was invoked with </td></tr>
    <tr><td class="paramname">weight</td><td>absorption coefficient </td></tr>
    <tr><td class="paramname">ior</td><td>the index of refraction of the bulk substrate medium </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>volume closure </dd></dl>

</div>
</div>
<a id="ga5ff07828789e0d6b51b8069a75aa842f" name="ga5ff07828789e0d6b51b8069a75aa842f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ff07828789e0d6b51b8069a75aa842f">&#9670;&nbsp;</a></span>AiClosureVolumeEmission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a> AiClosureVolumeEmission </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create volume emission closure, for volume shaders. </p>
<p >The closure weight is the emission coefficient. This coefficient is the rate at which the volume emits light along the given direction at the given point. Any ray that traverses a volume with a given emission coefficient will have radiance added at a rate of:</p>
<p >emission = emission_coefficient * distance_travelled</p>
<dl class="section note"><dt>Note</dt><dd>The volume's emission is itself affected by the volume's attenuation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals that the volume shader was invoked with </td></tr>
    <tr><td class="paramname">emission</td><td>emission coefficient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>volume closure </dd></dl>

</div>
</div>
<a id="gaf70e8d1f6acc3628d3217d3884ad9298" name="gaf70e8d1f6acc3628d3217d3884ad9298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf70e8d1f6acc3628d3217d3884ad9298">&#9670;&nbsp;</a></span>AiClosureVolumeHenyeyGreenstein()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a> AiClosureVolumeHenyeyGreenstein </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>absorption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>scattering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>emission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create Henyey-Greenstein volume scattering closure, for volume shaders. </p>
<p >The scattering coefficient is the rate at which the volume in-scatters radiance along the given direction at the given point, and the 'g' parameter is the Henyey-Greenstein phase at the given point. These coefficients are used for both direct and indirect light paths, and the amount of in-scattered radiance is:</p>
<p >scattering = scattering_coefficient * HenyeyGreensteinPhaseFunc(g, sg-&gt;Ld, sg-&gt;Rd) * radiance * distance_travelled</p>
<p >The absorption and emission coefficients are the same as in the volume absorption and emission closures. Creating a single volume scattering closures with all coefficients is faster than creating separate closures for each coefficient.</p>
<dl class="section note"><dt>Note</dt><dd>The volume's scattering is itself affected by the volume's attenuation.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals that the volume shader was invoked with </td></tr>
    <tr><td class="paramname">absorption</td><td>absorption coefficient </td></tr>
    <tr><td class="paramname">scattering</td><td>scattering coefficient </td></tr>
    <tr><td class="paramname">emission</td><td>emission coefficient </td></tr>
    <tr><td class="paramname">g</td><td>Henyey-Greenstein phase anisotropy, in the open interval (-1,+1) where negative values mean backward anisotropic scattering, positive values mean forward anisotropic scattering, zero means isotropic scattering </td></tr>
    <tr><td class="paramname">g2</td><td>Henyey-Greenstein phase anisotropy for the secondary HG lobe (defaults to 0) </td></tr>
    <tr><td class="paramname">w2</td><td>weight of the secondary, blended HG lobe (defaults to 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>volume closure </dd></dl>

</div>
</div>
<a id="ga227911391a3a06154875f38400248e79" name="ga227911391a3a06154875f38400248e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga227911391a3a06154875f38400248e79">&#9670;&nbsp;</a></span>AiClosureVolumeDoubleHenyeyGreenstein()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a> AiClosureVolumeDoubleHenyeyGreenstein </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>absorption</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>scattering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>emission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>g2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This creates a linear mix of two Henyey-Greenstein phase function lobes, of the form: </p>
<pre class="fragment">     (1 - w2) * HenyeyGreensteinPhaseFunc(g, ..) + w2 * HenyeyGreensteinPhaseFunc(g2, ..)
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals that the volume shader was invoked with </td></tr>
    <tr><td class="paramname">absorption</td><td>absorption coefficient </td></tr>
    <tr><td class="paramname">scattering</td><td>scattering coefficient </td></tr>
    <tr><td class="paramname">emission</td><td>emission coefficient </td></tr>
    <tr><td class="paramname">g</td><td>Henyey-Greenstein phase anisotropy, in the open interval (-1,+1) where negative values mean backward anisotropic scattering, positive values mean forward anisotropic scattering, zero means isotropic scattering </td></tr>
    <tr><td class="paramname">g2</td><td>Henyey-Greenstein phase anisotropy for the secondary HG lobe (defaults to 0) </td></tr>
    <tr><td class="paramname">w2</td><td>mix weight of the secondary HG lobe (defaults to 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>volume closure </dd></dl>

</div>
</div>
<a id="gad4f6ebf71513a1a3b32f54b745c33ef9" name="gad4f6ebf71513a1a3b32f54b745c33ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4f6ebf71513a1a3b32f54b745c33ef9">&#9670;&nbsp;</a></span>AiClosureVolumeMatte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a> AiClosureVolumeMatte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create volume matte closure, for volume shaders. </p>
<p >If used in place of <code><a class="el" href="group__ai__shader__closure.html#gac5915559e8a125d4cf4376f43583b2a3" title="Create volume absorption closure, for volume shaders.">AiClosureVolumeAbsorption()</a></code>, this works the same as the matte parameter on shapes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals that the volume shader was invoked with </td></tr>
    <tr><td class="paramname">weight</td><td>absorption coefficient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>volume closure </dd></dl>

</div>
</div>
<a id="ga23d1565d2f66561f65582ddf6b9c89d3" name="ga23d1565d2f66561f65582ddf6b9c89d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga23d1565d2f66561f65582ddf6b9c89d3">&#9670;&nbsp;</a></span>AiClosureVolumeAtmosphere()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AI_API AI_DEVICE <a class="el" href="structAtClosure.html">AtClosure</a> AiClosureVolumeAtmosphere </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structAtShaderGlobals.html">AtShaderGlobals</a> *&#160;</td>
          <td class="paramname"><em>sg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>emission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>transparent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structAtRGB.html">AtRGB</a> &amp;&#160;</td>
          <td class="paramname"><em>matte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create volume atmosphere closure, for legacy atmosphere shaders. </p>
<p >The weights are the total emission, transparency and matte transparency integrated over the volume segment with length <code>sg-&gt;Rl</code>. Such weights maybe be more convenient and numerically stable for legacy atmosphere shaders that cover long volume segment distances.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sg</td><td>shader globals </td></tr>
    <tr><td class="paramname">emission</td><td>integrated emission, equivalent to <code>AiClosureEmission</code> weight for surfaces </td></tr>
    <tr><td class="paramname">transparent</td><td>integrated transparency, equivalent to <code>AiClosureTransparent</code> weight for surfaces </td></tr>
    <tr><td class="paramname">matte</td><td>integrated matte transparency, equivalent to <code>AiClosureMatte</code> weight for surfaces </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>volume atmosphere closure </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<br>
<!--We could define a thematic change here by using the tag <hr class="footer"/> -->
<div id="geninfo" style="text-align: center;">
 <font size=-2 color=#C9C9C9>&copy 2023 Autodesk, Inc. &middot All rights reserved &middot <a href="http://www.arnoldrenderer.com/"><font size=-2 color=#C9C9C9>www.arnoldrenderer.com</font></a></font>
 <div id="geninfo" style="text-align: right; margin-top: 10 px; margin-right: 10px;">
 </div>
</div>
</body>
</html>
