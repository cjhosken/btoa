#usda 1.0
(
    "WARNING: THIS FILE IS GENERATED BY usdGenSchemaArnold. DO NOT EDIT."
)

class ArnoldUsdLuxLightFilter "ArnoldUsdLuxLightFilter"
{
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class ArnoldNodeGraph "ArnoldNodeGraph"
{
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class ArnoldOptions "ArnoldOptions"
{
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
}

class "ArnoldCamera"
{
    float arnold:exposure = 0
    float arnold:far_clip = 1e30
    string arnold:filtermap = ""
    token arnold:handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    vector3f[] arnold:look_at
    matrix4d[] arnold:matrix
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    float arnold:near_clip = 0.0001
    vector3f[] arnold:position
    token arnold:rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float arnold:rolling_shutter_duration = 0
    float2[] arnold:screen_window_max
    float2[] arnold:screen_window_min
    float2[] arnold:shutter_curve
    float arnold:shutter_end = 0
    float arnold:shutter_start = 0
    token arnold:shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    vector3f[] arnold:up
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldCameraAPI"
{
    float primvars:arnold:exposure = 0
    string primvars:arnold:filtermap = ""
    token primvars:arnold:handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    vector3f[] primvars:arnold:look_at
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    vector3f[] primvars:arnold:position
    token primvars:arnold:rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float primvars:arnold:rolling_shutter_duration = 0
    float2[] primvars:arnold:screen_window_max
    float2[] primvars:arnold:screen_window_min
    float2[] primvars:arnold:shutter_curve
    token primvars:arnold:shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    vector3f[] primvars:arnold:up
}

class "ArnoldLight"
{
    string arnold:aov = "default"
    bool arnold:cast_shadows = 1
    bool arnold:cast_volumetric_shadows = 1
    color3f arnold:color = (1, 1, 1)
    float arnold:diffuse = 1
    float arnold:exposure = 0
    string[] arnold:filters
    float arnold:indirect = 1
    float arnold:intensity = 1
    matrix4d[] arnold:matrix
    int arnold:max_bounces = 999
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:normalize = 1
    int arnold:samples = 1
    color3f arnold:shadow_color = (0, 0, 0)
    float arnold:shadow_density = 1
    float arnold:specular = 1
    float arnold:sss = 1
    float arnold:volume = 1
    int arnold:volume_samples = 2
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldLightAPI"
{
    string primvars:arnold:aov = "default"
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    string[] primvars:arnold:filters
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class "ArnoldDriver"
{
    string arnold:input = ""
}

class "ArnoldImager"
{
    bool arnold:enable = 1
    string arnold:input = ""
    string arnold:layer_selection = "*"
}

class "ArnoldFilter"
{
}

class "ArnoldShape"
{
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldShapeAPI"
{
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    string[] primvars:arnold:light_group
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    string[] primvars:arnold:shader
    string[] primvars:arnold:shadow_group
    uchar primvars:arnold:sidedness = 255
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
}

class "ArnoldColorManager"
{
    string arnold:color_space_linear = ""
    string arnold:color_space_narrow = ""
    asset arnold:config = @@
    bool arnold:ignore_environment_variable = 0
    float[] arnold:linear_chromaticities
}

class "ArnoldOperator"
{
    bool arnold:enable = 1
    string[] arnold:inputs
}

class ArnoldPerspCamera "ArnoldPerspCamera"
{
    float arnold:aperture_aspect_ratio = 1
    float arnold:aperture_blade_curvature = 0
    int arnold:aperture_blades = 0
    float arnold:aperture_rotation = 0
    float[] arnold:aperture_size
    float arnold:exposure = 0
    float arnold:far_clip = 1e30
    string arnold:filtermap = ""
    bool arnold:flat_field_focus = 1
    float[] arnold:focus_distance
    float[] arnold:fov
    token arnold:handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    float2[] arnold:lens_shift
    float2[] arnold:lens_tilt_angle
    vector3f[] arnold:look_at
    matrix4d[] arnold:matrix
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    float arnold:near_clip = 0.0001
    bool arnold:plane_distance = 1
    vector3f[] arnold:position
    float arnold:radial_distortion = 0
    token arnold:radial_distortion_type = "cubic" (
        allowedTokens = ["cubic", "cubic_inverse"]
    )
    token arnold:rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float arnold:rolling_shutter_duration = 0
    float2[] arnold:screen_window_max
    float2[] arnold:screen_window_min
    float2[] arnold:shutter_curve
    float arnold:shutter_end = 0
    float arnold:shutter_start = 0
    token arnold:shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    vector3f[] arnold:up
    color4f arnold:uv_remap = (0, 0, 0, 0)
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldPerspCameraAPI"
{
    float primvars:arnold:aperture_aspect_ratio = 1
    float primvars:arnold:aperture_blade_curvature = 0
    int primvars:arnold:aperture_blades = 0
    float primvars:arnold:aperture_rotation = 0
    float[] primvars:arnold:aperture_size
    float primvars:arnold:exposure = 0
    string primvars:arnold:filtermap = ""
    bool primvars:arnold:flat_field_focus = 1
    float[] primvars:arnold:fov
    token primvars:arnold:handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    float2[] primvars:arnold:lens_shift
    float2[] primvars:arnold:lens_tilt_angle
    vector3f[] primvars:arnold:look_at
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:plane_distance = 1
    vector3f[] primvars:arnold:position
    float primvars:arnold:radial_distortion = 0
    token primvars:arnold:radial_distortion_type = "cubic" (
        allowedTokens = ["cubic", "cubic_inverse"]
    )
    token primvars:arnold:rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float primvars:arnold:rolling_shutter_duration = 0
    float2[] primvars:arnold:screen_window_max
    float2[] primvars:arnold:screen_window_min
    float2[] primvars:arnold:shutter_curve
    token primvars:arnold:shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    vector3f[] primvars:arnold:up
    color4f primvars:arnold:uv_remap = (0, 0, 0, 0)
}

class ArnoldOrthoCamera "ArnoldOrthoCamera"
{
    float arnold:exposure = 0
    float arnold:far_clip = 1e30
    string arnold:filtermap = ""
    token arnold:handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    vector3f[] arnold:look_at
    matrix4d[] arnold:matrix
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    float arnold:near_clip = 0.0001
    vector3f[] arnold:position
    token arnold:rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float arnold:rolling_shutter_duration = 0
    float2[] arnold:screen_window_max
    float2[] arnold:screen_window_min
    float2[] arnold:shutter_curve
    float arnold:shutter_end = 0
    float arnold:shutter_start = 0
    token arnold:shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    vector3f[] arnold:up
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldOrthoCameraAPI"
{
    float primvars:arnold:exposure = 0
    string primvars:arnold:filtermap = ""
    token primvars:arnold:handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    vector3f[] primvars:arnold:look_at
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    vector3f[] primvars:arnold:position
    token primvars:arnold:rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float primvars:arnold:rolling_shutter_duration = 0
    float2[] primvars:arnold:screen_window_max
    float2[] primvars:arnold:screen_window_min
    float2[] primvars:arnold:shutter_curve
    token primvars:arnold:shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    vector3f[] primvars:arnold:up
}

class ArnoldFisheyeCamera "ArnoldFisheyeCamera"
{
    float arnold:aperture_aspect_ratio = 1
    float arnold:aperture_blade_curvature = 0
    int arnold:aperture_blades = 0
    float arnold:aperture_rotation = 0
    float[] arnold:aperture_size
    bool arnold:autocrop = 0
    float arnold:exposure = 0
    float arnold:far_clip = 1e30
    string arnold:filtermap = ""
    float[] arnold:focus_distance
    float[] arnold:fov
    token arnold:handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    vector3f[] arnold:look_at
    matrix4d[] arnold:matrix
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    float arnold:near_clip = 0.0001
    vector3f[] arnold:position
    token arnold:rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float arnold:rolling_shutter_duration = 0
    float2[] arnold:screen_window_max
    float2[] arnold:screen_window_min
    float2[] arnold:shutter_curve
    float arnold:shutter_end = 0
    float arnold:shutter_start = 0
    token arnold:shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    vector3f[] arnold:up
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldCylCamera "ArnoldCylCamera"
{
    float arnold:exposure = 0
    float arnold:far_clip = 1e30
    string arnold:filtermap = ""
    token arnold:handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    float[] arnold:horizontal_fov
    vector3f[] arnold:look_at
    matrix4d[] arnold:matrix
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    float arnold:near_clip = 0.0001
    vector3f[] arnold:position
    bool arnold:projective = 1
    token arnold:rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float arnold:rolling_shutter_duration = 0
    float2[] arnold:screen_window_max
    float2[] arnold:screen_window_min
    float2[] arnold:shutter_curve
    float arnold:shutter_end = 0
    float arnold:shutter_start = 0
    token arnold:shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    vector3f[] arnold:up
    float[] arnold:vertical_fov
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldSphericalCamera "ArnoldSphericalCamera"
{
    float arnold:exposure = 0
    float arnold:far_clip = 1e30
    string arnold:filtermap = ""
    token arnold:handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    vector3f[] arnold:look_at
    matrix4d[] arnold:matrix
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    float arnold:near_clip = 0.0001
    vector3f[] arnold:position
    token arnold:rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float arnold:rolling_shutter_duration = 0
    float2[] arnold:screen_window_max
    float2[] arnold:screen_window_min
    float2[] arnold:shutter_curve
    float arnold:shutter_end = 0
    float arnold:shutter_start = 0
    token arnold:shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    vector3f[] arnold:up
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldVrCamera "ArnoldVrCamera"
{
    float arnold:bottom_merge_angle = 90
    token arnold:bottom_merge_mode = "cosine" (
        allowedTokens = ["none", "cosine", "shader"]
    )
    float arnold:exposure = 0
    float arnold:eye_separation = 0.65
    float arnold:eye_to_neck = 0
    float arnold:far_clip = 1e30
    string arnold:filtermap = ""
    token arnold:handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    vector3f[] arnold:look_at
    matrix4d[] arnold:matrix
    float arnold:merge_shader = 0
    token arnold:mode = "side_by_side" (
        allowedTokens = ["side_by_side", "over_under", "left_eye", "right_eye"]
    )
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    float arnold:near_clip = 0.0001
    vector3f[] arnold:position
    token arnold:projection = "latlong" (
        allowedTokens = ["latlong", "cubemap_6x1", "cubemap_3x2"]
    )
    token arnold:rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float arnold:rolling_shutter_duration = 0
    float2[] arnold:screen_window_max
    float2[] arnold:screen_window_min
    float2[] arnold:shutter_curve
    float arnold:shutter_end = 0
    float arnold:shutter_start = 0
    token arnold:shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    float arnold:top_merge_angle = 90
    token arnold:top_merge_mode = "cosine" (
        allowedTokens = ["none", "cosine", "shader"]
    )
    vector3f[] arnold:up
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldUvCamera "ArnoldUvCamera"
{
    float arnold:exposure = 0
    bool arnold:extend_edges = 1
    float arnold:far_clip = 1e30
    string arnold:filtermap = ""
    int arnold:grid_size = 0
    token arnold:handedness = "right" (
        allowedTokens = ["right", "left"]
    )
    vector3f[] arnold:look_at
    matrix4d[] arnold:matrix
    string arnold:mesh = ""
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    float arnold:near_clip = 0.0001
    float arnold:offset = 0.1
    vector3f[] arnold:position
    string arnold:post_bake = ""
    vector3f arnold:ray_direction = (0, 0, 0)
    vector3f arnold:ray_origin = (0, 0, 0)
    token arnold:rolling_shutter = "off" (
        allowedTokens = ["off", "top", "bottom", "left", "right"]
    )
    float arnold:rolling_shutter_duration = 0
    float2[] arnold:screen_window_max
    float2[] arnold:screen_window_min
    float2[] arnold:shutter_curve
    float arnold:shutter_end = 0
    float arnold:shutter_start = 0
    token arnold:shutter_type = "box" (
        allowedTokens = ["box", "triangle", "curve"]
    )
    float arnold:u_offset = 0
    float arnold:u_scale = 1
    vector3f[] arnold:up
    string arnold:uv_set = ""
    float arnold:v_offset = 0
    float arnold:v_scale = 1
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldPointLight "ArnoldPointLight"
{
    string arnold:aov = "default"
    float arnold:camera = 0
    bool arnold:cast_shadows = 1
    bool arnold:cast_volumetric_shadows = 1
    color3f arnold:color = (1, 1, 1)
    float arnold:diffuse = 1
    float arnold:exposure = 0
    string[] arnold:filters
    float arnold:indirect = 1
    float arnold:intensity = 1
    matrix4d[] arnold:matrix
    int arnold:max_bounces = 999
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:normalize = 1
    vector3f[] arnold:position
    float arnold:radius = 0
    int arnold:samples = 1
    color3f arnold:shadow_color = (0, 0, 0)
    float arnold:shadow_density = 1
    float arnold:specular = 1
    float arnold:sss = 1
    float arnold:transmission = 0
    float arnold:volume = 1
    int arnold:volume_samples = 2
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldPointLightAPI"
{
    string primvars:arnold:aov = "default"
    float primvars:arnold:camera = 0
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    string[] primvars:arnold:filters
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:transmission = 0
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class ArnoldDistantLight "ArnoldDistantLight"
{
    float arnold:angle = 0
    string arnold:aov = "default"
    bool arnold:cast_shadows = 1
    bool arnold:cast_volumetric_shadows = 1
    color3f arnold:color = (1, 1, 1)
    float arnold:diffuse = 1
    vector3f[] arnold:direction
    float arnold:exposure = 0
    string[] arnold:filters
    float arnold:indirect = 1
    float arnold:intensity = 1
    matrix4d[] arnold:matrix
    int arnold:max_bounces = 999
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:normalize = 1
    int arnold:samples = 1
    color3f arnold:shadow_color = (0, 0, 0)
    float arnold:shadow_density = 1
    float arnold:specular = 1
    float arnold:sss = 1
    float arnold:volume = 1
    int arnold:volume_samples = 2
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldDistantLightAPI"
{
    string primvars:arnold:aov = "default"
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    vector3f[] primvars:arnold:direction
    string[] primvars:arnold:filters
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class ArnoldQuadLight "ArnoldQuadLight"
{
    string arnold:aov = "default"
    float arnold:camera = 0
    bool arnold:cast_shadows = 1
    bool arnold:cast_volumetric_shadows = 1
    color3f arnold:color = (1, 1, 1)
    float arnold:diffuse = 1
    float arnold:exposure = 0
    string[] arnold:filters
    float arnold:indirect = 1
    float arnold:intensity = 1
    matrix4d[] arnold:matrix
    int arnold:max_bounces = 999
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:normalize = 1
    bool arnold:portal = 0
    int arnold:resolution = 512
    float arnold:roundness = 0
    int arnold:samples = 1
    color3f arnold:shadow_color = (0, 0, 0)
    float arnold:shadow_density = 1
    float arnold:soft_edge = 0
    float arnold:specular = 1
    float arnold:spread = 1
    float arnold:sss = 1
    float arnold:transmission = 0
    vector3f[] arnold:vertices
    float arnold:volume = 1
    int arnold:volume_samples = 2
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldQuadLightAPI"
{
    string primvars:arnold:aov = "default"
    float primvars:arnold:camera = 0
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    string[] primvars:arnold:filters
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:portal = 0
    int primvars:arnold:resolution = 512
    float primvars:arnold:roundness = 0
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:soft_edge = 0
    float primvars:arnold:spread = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:transmission = 0
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class ArnoldSpotLight "ArnoldSpotLight"
{
    string arnold:aov = "default"
    float arnold:aspect_ratio = 1
    bool arnold:cast_shadows = 1
    bool arnold:cast_volumetric_shadows = 1
    color3f arnold:color = (1, 1, 1)
    float arnold:cone_angle = 65
    float arnold:cosine_power = 0
    float arnold:diffuse = 1
    float arnold:exposure = 0
    string[] arnold:filters
    float arnold:indirect = 1
    float arnold:intensity = 1
    float arnold:lens_radius = 0
    vector3f[] arnold:look_at
    matrix4d[] arnold:matrix
    int arnold:max_bounces = 999
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:normalize = 1
    float arnold:penumbra_angle = 0
    vector3f[] arnold:position
    float arnold:radius = 0
    float arnold:roundness = 1
    int arnold:samples = 1
    color3f arnold:shadow_color = (0, 0, 0)
    float arnold:shadow_density = 1
    float arnold:specular = 1
    float arnold:sss = 1
    vector3f[] arnold:up
    float arnold:volume = 1
    int arnold:volume_samples = 2
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldSkydomeLight "ArnoldSkydomeLight"
{
    string arnold:aov = "default"
    bool arnold:aov_indirect = 0
    float arnold:camera = 1
    bool arnold:cast_shadows = 1
    bool arnold:cast_volumetric_shadows = 1
    color3f arnold:color = (1, 1, 1)
    float arnold:diffuse = 1
    float arnold:exposure = 0
    string[] arnold:filters
    token arnold:format = "angular" (
        allowedTokens = ["mirrored_ball", "angular", "latlong"]
    )
    float arnold:indirect = 1
    float arnold:intensity = 1
    matrix4d[] arnold:matrix
    int arnold:max_bounces = 999
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:normalize = 1
    token arnold:portal_mode = "interior_only" (
        allowedTokens = ["off", "interior_only", "interior_exterior"]
    )
    int arnold:resolution = 1000
    int arnold:samples = 1
    string arnold:shader = ""
    color3f arnold:shadow_color = (0, 0, 0)
    float arnold:shadow_density = 1
    float arnold:specular = 1
    float arnold:sss = 1
    float arnold:transmission = 1
    float arnold:volume = 1
    int arnold:volume_samples = 2
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldSkydomeLightAPI"
{
    string primvars:arnold:aov = "default"
    bool primvars:arnold:aov_indirect = 0
    float primvars:arnold:camera = 1
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    string[] primvars:arnold:filters
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    token primvars:arnold:portal_mode = "interior_only" (
        allowedTokens = ["off", "interior_only", "interior_exterior"]
    )
    int primvars:arnold:resolution = 1000
    int primvars:arnold:samples = 1
    string primvars:arnold:shader = ""
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:transmission = 1
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class ArnoldCylinderLight "ArnoldCylinderLight"
{
    string arnold:aov = "default"
    vector3f[] arnold:bottom
    float arnold:camera = 0
    bool arnold:cast_shadows = 1
    bool arnold:cast_volumetric_shadows = 1
    color3f arnold:color = (1, 1, 1)
    float arnold:diffuse = 1
    float arnold:exposure = 0
    string[] arnold:filters
    float arnold:indirect = 1
    float arnold:intensity = 1
    matrix4d[] arnold:matrix
    int arnold:max_bounces = 999
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:normalize = 1
    float arnold:radius = 1
    int arnold:samples = 1
    color3f arnold:shadow_color = (0, 0, 0)
    float arnold:shadow_density = 1
    float arnold:specular = 1
    float arnold:sss = 1
    vector3f[] arnold:top
    float arnold:transmission = 0
    float arnold:volume = 1
    int arnold:volume_samples = 2
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldDiskLight "ArnoldDiskLight"
{
    string arnold:aov = "default"
    float arnold:camera = 0
    bool arnold:cast_shadows = 1
    bool arnold:cast_volumetric_shadows = 1
    color3f arnold:color = (1, 1, 1)
    float arnold:diffuse = 1
    vector3f[] arnold:direction
    float arnold:exposure = 0
    string[] arnold:filters
    float arnold:indirect = 1
    float arnold:intensity = 1
    matrix4d[] arnold:matrix
    int arnold:max_bounces = 999
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:normalize = 1
    vector3f[] arnold:position
    float arnold:radius = 0.5
    int arnold:samples = 1
    color3f arnold:shadow_color = (0, 0, 0)
    float arnold:shadow_density = 1
    float arnold:specular = 1
    float arnold:spread = 1
    float arnold:sss = 1
    float arnold:transmission = 0
    float arnold:volume = 1
    int arnold:volume_samples = 2
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldDiskLightAPI"
{
    string primvars:arnold:aov = "default"
    float primvars:arnold:camera = 0
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    vector3f[] primvars:arnold:direction
    string[] primvars:arnold:filters
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    vector3f[] primvars:arnold:position
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:spread = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:transmission = 0
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class ArnoldMeshLight "ArnoldMeshLight"
{
    string arnold:aov = "default"
    bool arnold:cast_shadows = 1
    bool arnold:cast_volumetric_shadows = 1
    color3f arnold:color = (1, 1, 1)
    float arnold:diffuse = 1
    float arnold:exposure = 0
    string[] arnold:filters
    float arnold:indirect = 1
    float arnold:intensity = 1
    matrix4d[] arnold:matrix
    int arnold:max_bounces = 999
    string arnold:mesh = ""
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:normalize = 1
    int arnold:samples = 1
    color3f arnold:shadow_color = (0, 0, 0)
    float arnold:shadow_density = 1
    float arnold:specular = 1
    float arnold:sss = 1
    float arnold:volume = 1
    int arnold:volume_samples = 2
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldMeshLightAPI"
{
    string primvars:arnold:aov = "default"
    bool primvars:arnold:cast_shadows = 1
    bool primvars:arnold:cast_volumetric_shadows = 1
    string[] primvars:arnold:filters
    float primvars:arnold:indirect = 1
    int primvars:arnold:max_bounces = 999
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    int primvars:arnold:samples = 1
    color3f primvars:arnold:shadow_color = (0, 0, 0)
    float primvars:arnold:shadow_density = 1
    float primvars:arnold:sss = 1
    float primvars:arnold:volume = 1
    int primvars:arnold:volume_samples = 2
}

class ArnoldPhotometricLight "ArnoldPhotometricLight"
{
    string arnold:aov = "default"
    bool arnold:cast_shadows = 1
    bool arnold:cast_volumetric_shadows = 1
    color3f arnold:color = (1, 1, 1)
    float arnold:diffuse = 1
    float arnold:exposure = 0
    asset arnold:filename = @@
    string[] arnold:filters
    float arnold:indirect = 1
    float arnold:intensity = 1
    matrix4d[] arnold:matrix
    int arnold:max_bounces = 999
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:normalize = 1
    float arnold:radius = 0
    int arnold:samples = 1
    color3f arnold:shadow_color = (0, 0, 0)
    float arnold:shadow_density = 1
    float arnold:specular = 1
    float arnold:sss = 1
    float arnold:volume = 1
    int arnold:volume_samples = 2
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldDriverJpeg "ArnoldDriverJpeg"
{
    string arnold:color_space = "auto"
    bool arnold:dither = 1
    asset arnold:filename = @output.jpg@
    string arnold:input = ""
    bool arnold:output_padded = 0
    int arnold:quality = 100
}

class ArnoldDriverNoOp "ArnoldDriverNoOp"
{
    string arnold:input = ""
}

class ArnoldDriverPng "ArnoldDriverPng"
{
    string arnold:color_space = "auto"
    bool arnold:dither = 1
    asset arnold:filename = @output.png@
    token arnold:format = "int8" (
        allowedTokens = ["int8", "int16"]
    )
    string arnold:input = ""
    bool arnold:output_padded = 0
    bool arnold:skip_alpha = 1
    bool arnold:unpremult_alpha = 0
}

class ArnoldDriverTiff "ArnoldDriverTiff"
{
    bool arnold:append = 0
    string arnold:color_space = "auto"
    token arnold:compression = "lzw" (
        allowedTokens = ["none", "lzw", "ccittrle", "zip", "packbits"]
    )
    bool arnold:dither = 1
    asset arnold:filename = @output.tif@
    token arnold:format = "int8" (
        allowedTokens = ["int8", "int16", "float32"]
    )
    string arnold:input = ""
    bool arnold:output_padded = 0
    bool arnold:skip_alpha = 0
    bool arnold:tiled = 0
    bool arnold:unpremult_alpha = 0
}

class ArnoldDriverDeepexr "ArnoldDriverDeepexr"
{
    bool arnold:alpha_half_precision = 0
    float arnold:alpha_tolerance = 0.01
    bool arnold:append = 0
    string[] arnold:custom_attributes
    bool arnold:depth_half_precision = 0
    float arnold:depth_tolerance = 0.01
    asset arnold:filename = @deep.exr@
    string arnold:input = ""
    bool[] arnold:layer_enable_filtering
    bool[] arnold:layer_half_precision
    float[] arnold:layer_tolerance
    bool arnold:subpixel_merge = 1
    bool arnold:tiled = 0
    bool arnold:use_RGB_opacity = 0
}

class ArnoldDriverExr "ArnoldDriverExr"
{
    bool arnold:append = 0
    bool arnold:autocrop = 0
    string arnold:color_space = "auto"
    token arnold:compression = "zip" (
        allowedTokens = ["none", "rle", "zips", "zip", "piz", "pxr24", "b44", "b44a", "dwaa", "dwab"]
    )
    string[] arnold:custom_attributes
    asset arnold:filename = @output.exr@
    bool arnold:half_precision = 0
    string arnold:input = ""
    bool arnold:multipart = 0
    bool arnold:preserve_layer_name = 0
    bool arnold:tiled = 1
}

class ArnoldImagerColorCorrect "ArnoldImagerColorCorrect"
{
    bool arnold:enable = 1
    float arnold:highlights_contrast = 1
    color3f arnold:highlights_gain = (1, 1, 1)
    float arnold:highlights_gamma = 1
    color3f arnold:highlights_offset = (0, 0, 0)
    float arnold:highlights_saturation = 1
    string arnold:input = ""
    string arnold:layer_selection = "*"
    float arnold:main_contrast = 1
    color3f arnold:main_gain = (1, 1, 1)
    float arnold:main_gamma = 1
    color3f arnold:main_offset = (0, 0, 0)
    float arnold:main_saturation = 1
    float arnold:midtones_contrast = 1
    color3f arnold:midtones_gain = (1, 1, 1)
    float arnold:midtones_gamma = 1
    color3f arnold:midtones_offset = (0, 0, 0)
    float arnold:midtones_saturation = 1
    float arnold:shadows_contrast = 1
    color3f arnold:shadows_gain = (1, 1, 1)
    float arnold:shadows_gamma = 1
    color3f arnold:shadows_offset = (0, 0, 0)
    float arnold:shadows_saturation = 1
}

class ArnoldImagerColorCurves "ArnoldImagerColorCurves"
{
    int[] arnold:B_interpolation
    float[] arnold:B_position
    float[] arnold:B_value
    bool arnold:enable = 1
    int[] arnold:G_interpolation
    float[] arnold:G_position
    float[] arnold:G_value
    string arnold:input = ""
    string arnold:layer_selection = "*"
    int[] arnold:R_interpolation
    float[] arnold:R_position
    float[] arnold:R_value
    int[] arnold:RGB_interpolation
    float[] arnold:RGB_position
    float[] arnold:RGB_value
    string arnold:working_color_space = ""
}

class ArnoldImagerDenoiserNoice "ArnoldImagerDenoiserNoice"
{
    bool arnold:enable = 1
    string arnold:input = ""
    string arnold:layer_selection = "*"
    string arnold:output_suffix = ""
    uint arnold:patch_radius = 3
    uint arnold:search_radius = 9
    uint arnold:tile_size = 64
    float arnold:variance = 0.25
}

class ArnoldImagerDenoiserOptix "ArnoldImagerDenoiserOptix"
{
    float arnold:blend = 1
    bool arnold:clamp = 0
    float arnold:clamp_max = 1
    float arnold:clamp_min = 0
    bool arnold:enable = 1
    string arnold:input = ""
    string arnold:layer_selection = "*"
    string arnold:output_suffix = ""
    bool arnold:use_feature_aovs = 1
}

class ArnoldImagerDenoiserOidn "ArnoldImagerDenoiserOidn"
{
    string arnold:albedo = "denoise_albedo_noisy"
    bool arnold:enable = 1
    string arnold:input = ""
    string arnold:layer_selection = "*"
    string arnold:output_suffix = ""
    token arnold:render_device = "metric_auto" (
        allowedTokens = ["metric_auto", "cpu", "gpu"]
    )
}

class ArnoldImagerExposure "ArnoldImagerExposure"
{
    bool arnold:enable = 1
    float arnold:exposure = 0
    string arnold:input = ""
    string arnold:layer_selection = "*"
}

class ArnoldImagerLensEffects "ArnoldImagerLensEffects"
{
    int arnold:bloom_radius = 4
    float arnold:bloom_strength = 0
    float arnold:bloom_threshold = 0.9
    color3f arnold:bloom_tint = (1, 1, 1)
    bool arnold:enable = 1
    string arnold:input = ""
    string arnold:layer_selection = "*"
    float arnold:vignetting = 0
}

class ArnoldImagerLightMixer "ArnoldImagerLightMixer"
{
    bool arnold:enable = 1
    string arnold:input = ""
    bool[] arnold:layer_enable
    float[] arnold:layer_exposure
    float[] arnold:layer_intensity
    string[] arnold:layer_name
    string arnold:layer_selection = "*"
    bool[] arnold:layer_solo
    color3f[] arnold:layer_tint
    string arnold:output_name = "RGBA"
}

class ArnoldImagerOverlay "ArnoldImagerOverlay"
{
    bool arnold:adjust_font_size = 1
    color3f arnold:background_color = (0.05, 0.05, 0.05)
    float arnold:background_opacity = 0.7
    bool arnold:enable = 1
    string arnold:font = ""
    color3f arnold:font_color = (1, 1, 1)
    int arnold:font_size = 24
    token arnold:halign = "left" (
        allowedTokens = ["left", "center", "right"]
    )
    string arnold:input = ""
    string arnold:layer_selection = "*"
    int arnold:margin_bottom = 20
    int arnold:margin_left = 20
    int arnold:margin_right = 20
    int arnold:margin_top = 20
    string arnold:output_suffix = ""
    string arnold:text = "<frame_time> | <resolution> | <render_device> | <camera> | <samples> | <memory>"
    token arnold:valign = "bottom" (
        allowedTokens = ["top", "center", "bottom"]
    )
}

class ArnoldImagerTonemap "ArnoldImagerTonemap"
{
    bool arnold:enable = 1
    float arnold:filmic_shoulder_angle = 0
    float arnold:filmic_shoulder_length = 0.5
    float arnold:filmic_shoulder_strength = 0
    float arnold:filmic_toe_length = 0.5
    float arnold:filmic_toe_strength = 0
    float arnold:gamma = 1
    token arnold:heatmap_input_mode = "length" (
        allowedTokens = ["length", "min", "max"]
    )
    float arnold:heatmap_max = 1
    float arnold:heatmap_min = 0
    string arnold:input = ""
    string arnold:layer_selection = "*"
    asset arnold:lut_filename = @@
    string arnold:lut_working_color_space = ""
    float arnold:mix = 1
    token arnold:mode = "filmic" (
        allowedTokens = ["filmic", "reinhard", "lut", "heatmap"]
    )
    bool arnold:preserve_saturation = 0
    float arnold:reinhard_highlights = 1
    float arnold:reinhard_shadows = 0
}

class ArnoldImagerWhiteBalance "ArnoldImagerWhiteBalance"
{
    color3f arnold:custom = (1, 1, 1)
    bool arnold:enable = 1
    token arnold:illuminant = "daylight" (
        allowedTokens = ["daylight", "sun", "shade", "overcast", "incandescent", "fluorescent", "cie_a", "cie_50", "cie_55", "cie_65", "cie_75", "cie_f1", "cie_f2", "cie_f3", "cie_f4", "cie_f5", "cie_f6", "cie_f7", "cie_f8", "cie_f9", "cie_f10", "cie_f11", "cie_f12", "halogen_warm", "halogen_basic", "halogen_cool", "ceramic_halide_warm", "ceramic_halide_cool", "quartz_halide_warm", "quartz_halide", "quartz_halide_cool", "mercury", "phosphor_mercury", "xenon", "high_press_sodium", "low_press_sodium"]
    )
    string arnold:input = ""
    string arnold:layer_selection = "*"
    token arnold:mode = "illuminant" (
        allowedTokens = ["illuminant", "temperature", "custom"]
    )
    float arnold:temperature = 6500
}

class ArnoldBoxFilter "ArnoldBoxFilter"
{
}

class ArnoldTriangleFilter "ArnoldTriangleFilter"
{
    float arnold:width = 2
}

class ArnoldCatromFilter "ArnoldCatromFilter"
{
}

class ArnoldMitnetFilter "ArnoldMitnetFilter"
{
}

class ArnoldGaussianFilter "ArnoldGaussianFilter"
{
    float arnold:width = 2
}

class ArnoldSincFilter "ArnoldSincFilter"
{
    float arnold:width = 6
}

class ArnoldBlackmanHarrisFilter "ArnoldBlackmanHarrisFilter"
{
    float arnold:width = 3
}

class ArnoldClosestFilter "ArnoldClosestFilter"
{
}

class ArnoldFarthestFilter "ArnoldFarthestFilter"
{
    token arnold:domain = "first_hit" (
        allowedTokens = ["first_hit", "all_hits"]
    )
}

class ArnoldVarianceFilter "ArnoldVarianceFilter"
{
    token arnold:filter_weights = "box" (
        allowedTokens = ["blackman_harris", "box", "catrom", "gaussian", "mitnet", "sinc", "triangle"]
    )
    bool arnold:scalar_mode = 0
    float arnold:width = 2
}

class ArnoldHeatmapFilter "ArnoldHeatmapFilter"
{
    float arnold:maximum = 1
    float arnold:minimum = 0
}

class ArnoldContourFilter "ArnoldContourFilter"
{
    float arnold:width = 1
}

class ArnoldDiffFilter "ArnoldDiffFilter"
{
    token arnold:filter_weights = "box" (
        allowedTokens = ["blackman_harris", "box", "catrom", "gaussian", "mitnet", "sinc", "triangle"]
    )
    float arnold:width = 2
}

class ArnoldCryptomatteFilter "ArnoldCryptomatteFilter"
{
    token arnold:filter = "gaussian" (
        allowedTokens = ["box", "triangle", "catrom", "mitnet", "gaussian", "sinc", "blackman_harris", "disk", "cone"]
    )
    bool arnold:noop = 0
    float arnold:width = 2
}

class ArnoldSphere "ArnoldSphere"
{
    vector3f[] arnold:center
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float[] arnold:radius
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    float arnold:step_size = 0
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    float arnold:volume_padding = 0
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldSphereAPI"
{
    vector3f[] primvars:arnold:center
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    string[] primvars:arnold:light_group
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    string[] primvars:arnold:shadow_group
    uchar primvars:arnold:sidedness = 255
    float primvars:arnold:step_size = 0
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
    float primvars:arnold:volume_padding = 0
}

class ArnoldCylinder "ArnoldCylinder"
{
    float arnold:bevel_angle = 0.5
    float arnold:bevel_width = 0
    vector3f arnold:bottom = (0, 0, -0.5)
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float arnold:radius = 0.5
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    vector3f arnold:top = (0, 0, 0.5)
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldCylinderAPI"
{
    float primvars:arnold:bevel_angle = 0.5
    float primvars:arnold:bevel_width = 0
    vector3f primvars:arnold:bottom = (0, 0, -0.5)
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    string[] primvars:arnold:light_group
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    string[] primvars:arnold:shadow_group
    uchar primvars:arnold:sidedness = 255
    vector3f primvars:arnold:top = (0, 0, 0.5)
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
}

class ArnoldCone "ArnoldCone"
{
    vector3f arnold:bottom = (0, 0, -0.5)
    float arnold:bottom_radius = 0.5
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    vector3f arnold:top = (0, 0, 0.5)
    float arnold:top_radius = 0
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldConeAPI"
{
    vector3f primvars:arnold:bottom = (0, 0, -0.5)
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    string[] primvars:arnold:light_group
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    string[] primvars:arnold:shadow_group
    uchar primvars:arnold:sidedness = 255
    vector3f primvars:arnold:top = (0, 0, 0.5)
    float primvars:arnold:top_radius = 0
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
}

class ArnoldDisk "ArnoldDisk"
{
    float arnold:bevel_angle = 0.5
    float arnold:bevel_width = 0
    vector3f arnold:center = (0, 0, 0)
    float arnold:hole = 0
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    vector3f arnold:normal = (0, 0, 1)
    bool arnold:opaque = 1
    float arnold:radius = 0.5
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldPlane "ArnoldPlane"
{
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    vector3f arnold:normal = (0, 0, 1)
    bool arnold:opaque = 1
    vector3f arnold:point = (0, 0, 0)
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldPolymesh "ArnoldPolymesh"
{
    uchar arnold:autobump_visibility = 1
    uint[] arnold:crease_idxs
    float[] arnold:crease_sharpness
    bool arnold:disp_autobump = 0
    float arnold:disp_height = 1
    string[] arnold:disp_map
    float arnold:disp_padding = 0
    float arnold:disp_zero_value = 0
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    uint[] arnold:nidxs
    vector3f[] arnold:nlist
    uint[] arnold:nsides
    bool arnold:opaque = 1
    uint[] arnold:polygon_holes
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar[] arnold:shidxs
    uchar arnold:sidedness = 255
    bool arnold:smoothing = 1
    float arnold:step_size = 0
    float arnold:subdiv_adaptive_error = 0
    token arnold:subdiv_adaptive_metric = "metric_auto" (
        allowedTokens = ["metric_auto", "edge_length", "flatness"]
    )
    token arnold:subdiv_adaptive_space = "raster" (
        allowedTokens = ["raster", "object"]
    )
    bool arnold:subdiv_frustum_ignore = 0
    uchar arnold:subdiv_iterations = 1
    bool arnold:subdiv_smooth_derivs = 0
    token arnold:subdiv_type = "none" (
        allowedTokens = ["none", "catclark", "linear"]
    )
    token arnold:subdiv_uv_smoothing = "pin_corners" (
        allowedTokens = ["pin_corners", "pin_borders", "linear", "smooth"]
    )
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uint[] arnold:uvidxs
    float2[] arnold:uvlist
    uint[] arnold:vidxs
    uchar arnold:visibility = 255
    vector3f[] arnold:vlist
    float arnold:volume_padding = 0
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldPolymeshAPI"
{
    uchar primvars:arnold:autobump_visibility = 1
    uint[] primvars:arnold:crease_idxs
    float[] primvars:arnold:crease_sharpness
    bool primvars:arnold:disp_autobump = 0
    float primvars:arnold:disp_height = 1
    string[] primvars:arnold:disp_map
    float primvars:arnold:disp_padding = 0
    float primvars:arnold:disp_zero_value = 0
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    string[] primvars:arnold:light_group
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    vector3f[] primvars:arnold:nlist
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    string[] primvars:arnold:shadow_group
    uchar[] primvars:arnold:shidxs
    uchar primvars:arnold:sidedness = 255
    bool primvars:arnold:smoothing = 1
    float primvars:arnold:step_size = 0
    float primvars:arnold:subdiv_adaptive_error = 0
    token primvars:arnold:subdiv_adaptive_metric = "metric_auto" (
        allowedTokens = ["metric_auto", "edge_length", "flatness"]
    )
    token primvars:arnold:subdiv_adaptive_space = "raster" (
        allowedTokens = ["raster", "object"]
    )
    bool primvars:arnold:subdiv_frustum_ignore = 0
    uchar primvars:arnold:subdiv_iterations = 1
    bool primvars:arnold:subdiv_smooth_derivs = 0
    token primvars:arnold:subdiv_type = "none" (
        allowedTokens = ["none", "catclark", "linear"]
    )
    token primvars:arnold:subdiv_uv_smoothing = "pin_corners" (
        allowedTokens = ["pin_corners", "pin_borders", "linear", "smooth"]
    )
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uint[] primvars:arnold:uvidxs
    float2[] primvars:arnold:uvlist
    uchar primvars:arnold:visibility = 255
    vector3f[] primvars:arnold:vlist
    float primvars:arnold:volume_padding = 0
}

class ArnoldNurbs "ArnoldNurbs"
{
    uchar arnold:autobump_visibility = 1
    float[] arnold:cvs
    int arnold:degree_u = 3
    int arnold:degree_v = 3
    bool arnold:disp_autobump = 0
    float arnold:disp_height = 0
    string arnold:disp_map = ""
    float arnold:disp_padding = 0
    float arnold:disp_zero_value = 0
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    float[] arnold:knots_u
    float[] arnold:knots_v
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    bool arnold:smoothing = 1
    float arnold:step_size = 0
    int arnold:tesselate_u = 5
    int arnold:tesselate_v = 5
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    float arnold:volume_padding = 0
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldBox "ArnoldBox"
{
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    vector3f arnold:max = (0.5, 0.5, 0.5)
    vector3f arnold:min = (-0.5, -0.5, -0.5)
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    float arnold:step_size = 0
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    float arnold:volume_padding = 0
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldBoxAPI"
{
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    string[] primvars:arnold:light_group
    bool primvars:arnold:matte = 0
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    string[] primvars:arnold:shadow_group
    uchar primvars:arnold:sidedness = 255
    float primvars:arnold:step_size = 0
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
    float primvars:arnold:volume_padding = 0
}

class ArnoldCurves "ArnoldCurves"
{
    token arnold:basis = "bezier" (
        allowedTokens = ["bezier", "b-spline", "catmull-rom", "linear"]
    )
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:min_pixel_width = 0
    token arnold:mode = "ribbon" (
        allowedTokens = ["ribbon", "thick", "oriented"]
    )
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    uint[] arnold:num_points
    bool arnold:opaque = 1
    vector3f[] arnold:orientations
    vector3f[] arnold:points
    float[] arnold:radius
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar[] arnold:shidxs
    uchar arnold:sidedness = 255
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    float2[] arnold:uvs
    uchar arnold:visibility = 255
    token arnold:wrap_mode = "nonperiodic" (
        allowedTokens = ["nonperiodic", "periodic", "pinned"]
    )
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldCurvesAPI"
{
    token primvars:arnold:basis = "bezier" (
        allowedTokens = ["bezier", "b-spline", "catmull-rom", "linear"]
    )
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    string[] primvars:arnold:light_group
    bool primvars:arnold:matte = 0
    float primvars:arnold:min_pixel_width = 0
    token primvars:arnold:mode = "ribbon" (
        allowedTokens = ["ribbon", "thick", "oriented"]
    )
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    vector3f[] primvars:arnold:orientations
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    bool primvars:arnold:self_shadows = 1
    string[] primvars:arnold:shadow_group
    uchar[] primvars:arnold:shidxs
    uchar primvars:arnold:sidedness = 255
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    float2[] primvars:arnold:uvs
    uchar primvars:arnold:visibility = 255
    token primvars:arnold:wrap_mode = "nonperiodic" (
        allowedTokens = ["nonperiodic", "periodic", "pinned"]
    )
}

class ArnoldPoints "ArnoldPoints"
{
    float[] arnold:aspect
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:min_pixel_width = 0
    token arnold:mode = "disk" (
        allowedTokens = ["disk", "sphere", "quad"]
    )
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    vector3f[] arnold:points
    float[] arnold:radius
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    float[] arnold:rotation
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    float arnold:step_size = 0
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    float arnold:volume_padding = 0
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class "ArnoldPointsAPI"
{
    float[] primvars:arnold:aspect
    uint primvars:arnold:id = 0
    bool primvars:arnold:invert_normals = 0
    string[] primvars:arnold:light_group
    bool primvars:arnold:matte = 0
    float primvars:arnold:min_pixel_width = 0
    token primvars:arnold:mode = "disk" (
        allowedTokens = ["disk", "sphere", "quad"]
    )
    float primvars:arnold:motion_end = 1
    float primvars:arnold:motion_start = 0
    bool primvars:arnold:opaque = 1
    float primvars:arnold:ray_bias = 0.000001
    bool primvars:arnold:receive_shadows = 1
    float[] primvars:arnold:rotation
    bool primvars:arnold:self_shadows = 1
    string[] primvars:arnold:shadow_group
    uchar primvars:arnold:sidedness = 255
    float primvars:arnold:step_size = 0
    string[] primvars:arnold:trace_sets
    token primvars:arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool primvars:arnold:use_light_group = 0
    bool primvars:arnold:use_shadow_group = 0
    uchar primvars:arnold:visibility = 255
    float primvars:arnold:volume_padding = 0
}

class ArnoldImplicit "ArnoldImplicit"
{
    string arnold:field = ""
    string arnold:field_channel = "field"
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    vector3f arnold:max = (0, 0, 0)
    vector3f arnold:min = (0, 0, 0)
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    uint arnold:samples = 10
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    token arnold:solver = "uniform" (
        allowedTokens = ["uniform", "levelset"]
    )
    float arnold:step_size = 0
    float arnold:threshold = 0
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldGinstance "ArnoldGinstance"
{
    uint arnold:id = 0
    bool arnold:inherit_xform = 1
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    string arnold:node = ""
    bool arnold:opaque = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    float arnold:step_size = 0
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldProcedural "ArnoldProcedural"
{
    bool arnold:auto_instancing = 1
    string arnold:data = ""
    asset arnold:filename = @@
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    string arnold:namespace = ""
    bool arnold:opaque = 1
    string arnold:operator = ""
    bool arnold:override_nodes = 0
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldListAggregate "ArnoldListAggregate"
{
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldVolume "ArnoldVolume"
{
    bool arnold:compress = 1
    uchar[] arnold:filedata
    asset arnold:filename = @@
    string[] arnold:grids
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    float arnold:step_scale = 1
    float arnold:step_size = 0
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    float arnold:velocity_fps = 24
    string[] arnold:velocity_grids
    float arnold:velocity_outlier_threshold = 0.001
    float arnold:velocity_scale = 1
    uchar arnold:visibility = 255
    float arnold:volume_padding = 0
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldVolumeImplicit "ArnoldVolumeImplicit"
{
    bool arnold:compress = 1
    string arnold:field = ""
    string arnold:field_channel = "field"
    uchar[] arnold:filedata
    asset arnold:filename = @@
    string[] arnold:grids
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    vector3f arnold:max = (0, 0, 0)
    vector3f arnold:min = (0, 0, 0)
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    bool arnold:opaque = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    uint arnold:samples = 10
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    token arnold:solver = "uniform" (
        allowedTokens = ["uniform", "levelset"]
    )
    float arnold:step_scale = 1
    float arnold:step_size = 0
    float arnold:threshold = 0
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    float arnold:velocity_fps = 24
    string[] arnold:velocity_grids
    float arnold:velocity_outlier_threshold = 0.001
    float arnold:velocity_scale = 1
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldInstancer "ArnoldInstancer"
{
    uint arnold:id = 0
    matrix4d[] arnold:instance_matrix
    string[] arnold:instance_shader
    uchar[] arnold:instance_visibility
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    string arnold:namespace = ""
    uint[] arnold:node_idxs
    string[] arnold:nodes
    bool arnold:opaque = 1
    string arnold:operator = ""
    bool arnold:override_nodes = 0
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldColorManagerOcio "ArnoldColorManagerOcio"
{
    string arnold:color_space_linear = ""
    string arnold:color_space_narrow = ""
    asset arnold:config = @@
    bool arnold:ignore_environment_variable = 0
    float[] arnold:linear_chromaticities
}

class ArnoldMaterialx "ArnoldMaterialx"
{
    bool arnold:assign_materials = 1
    bool arnold:assign_properties = 1
    token arnold:assign_type = "look" (
        allowedTokens = ["look", "material"]
    )
    bool arnold:assign_visibilities = 1
    bool arnold:enable = 1
    asset arnold:filename = @@
    string[] arnold:inputs
    string arnold:look = ""
    string arnold:selection = ""
}

class ArnoldMerge "ArnoldMerge"
{
    bool arnold:enable = 1
    string[] arnold:inputs
}

class ArnoldSetParameter "ArnoldSetParameter"
{
    string[] arnold:assignment
    bool arnold:enable = 1
    bool[] arnold:enable_assignment
    string[] arnold:inputs
    string arnold:selection = ""
}

class ArnoldDisable "ArnoldDisable"
{
    bool arnold:enable = 1
    string[] arnold:inputs
    bool arnold:lights = 1
    token arnold:mode = "disable" (
        allowedTokens = ["disable", "enable"]
    )
    bool arnold:operators = 1
    string arnold:selection = ""
    bool arnold:shaders = 1
    bool arnold:shapes = 1
}

class ArnoldSwitchOperator "ArnoldSwitchOperator"
{
    bool arnold:enable = 1
    int arnold:index = 0
    string[] arnold:inputs
}

class ArnoldSetTransform "ArnoldSetTransform"
{
    bool arnold:enable = 1
    string[] arnold:inputs
    matrix4d[] arnold:matrix
    token arnold:mode = "append" (
        allowedTokens = ["append", "replace"]
    )
    vector3f arnold:rotate = (0, 0, 0)
    token arnold:rotate_order = "xyz" (
        allowedTokens = ["xyz", "xzy", "yxz", "yzx", "zxy", "zyx"]
    )
    vector3f arnold:scale = (1, 1, 1)
    string arnold:selection = ""
    token arnold:transform_order = "srt" (
        allowedTokens = ["srt", "str", "tsr", "trs", "rst", "rts"]
    )
    vector3f arnold:translate = (0, 0, 0)
}

class ArnoldCollection "ArnoldCollection"
{
    string arnold:collection = ""
    bool arnold:enable = 1
    string[] arnold:inputs
    string arnold:selection = ""
}

class ArnoldIncludeGraph "ArnoldIncludeGraph"
{
    bool arnold:enable = 1
    asset arnold:filename = @@
    string[] arnold:inputs
    string arnold:target = ""
}

class ArnoldStringReplace "ArnoldStringReplace"
{
    bool arnold:enable = 1
    string[] arnold:inputs
    string arnold:match = ""
    token arnold:os = "any" (
        allowedTokens = ["any", "os_linux", "windows", "mac"]
    )
    string arnold:replace = ""
    string arnold:selection = ""
}

class ArnoldAlembic "ArnoldAlembic"
{
    bool arnold:exclude_xform = 0
    bool arnold:expand_hidden = 0
    asset arnold:filename = @@
    bool arnold:flip_v = 0
    float arnold:fps = 24
    float arnold:frame = 0
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:layers
    string[] arnold:light_group
    bool arnold:make_instance = 1
    string arnold:material_attribute = ""
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    string arnold:nameprefix = ""
    string arnold:namespace = ""
    string[] arnold:objectpath
    bool arnold:opaque = 1
    string arnold:operator = ""
    bool arnold:override_nodes = 0
    bool arnold:pull_user_params = 0
    string arnold:radius_attribute = ""
    float arnold:radius_default = 0.02
    float arnold:radius_scale = 1
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    string arnold:scene_camera = ""
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    float arnold:shutter_end = 0
    float arnold:shutter_start = 0
    uchar arnold:sidedness = 255
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_instance_cache = 1
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    bool arnold:velocity_ignore = 0
    float arnold:velocity_scale = 1
    uchar arnold:visibility = 255
    bool arnold:visibility_ignore = 0
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

class ArnoldProceduralCustom "ArnoldProceduralCustom"
{
    uint arnold:id = 0
    bool arnold:invert_normals = 0
    string[] arnold:light_group
    matrix4d[] arnold:matrix
    bool arnold:matte = 0
    float arnold:motion_end = 1
    float arnold:motion_start = 0
    string arnold:namespace = ""
    bool arnold:opaque = 1
    string arnold:operator = ""
    float arnold:ray_bias = 0.000001
    bool arnold:receive_shadows = 1
    bool arnold:self_shadows = 1
    string[] arnold:shader
    string[] arnold:shadow_group
    uchar arnold:sidedness = 255
    string[] arnold:trace_sets
    token arnold:transform_type = "rotate_about_center" (
        allowedTokens = ["linear", "rotate_about_origin", "rotate_about_center"]
    )
    bool arnold:use_light_group = 0
    bool arnold:use_shadow_group = 0
    uchar arnold:visibility = 255
    uniform bool doubleSided = 0 (
        doc = """Although some renderers treat all parametric or polygonal
        surfaces as if they were effectively laminae with outward-facing
        normals on both sides, some renderers derive significant optimizations
        by considering these surfaces to have only a single outward side,
        typically determined by control-point winding order and/or 
        orientation.  By doing so they can perform \"backface culling\" to
        avoid drawing the many polygons of most closed surfaces that face away
        from the viewer.
        
        However, it is often advantageous to model thin objects such as paper
        and cloth as single, open surfaces that must be viewable from both
        sides, always.  Setting a gprim's doubleSided attribute to 
        \\c true instructs all renderers to disable optimizations such as
        backface culling for the gprim, and attempt (not all renderers are able
        to do so, but the USD reference GL renderer always will) to provide
        forward-facing normals on each side of the surface for lighting
        calculations."""
    )
    float3[] extent (
        doc = """Extent is a three dimensional range measuring the geometric
        extent of the authored gprim in its own local space (i.e. its own
        transform not applied), without accounting for any shader-induced
        displacement. If __any__ extent value has been authored for a given 
        Boundable, then it should be authored at every timeSample at which 
        geometry-affecting properties are authored, to ensure correct 
        evaluation via ComputeExtent(). If __no__ extent value has been 
        authored, then ComputeExtent() will call the Boundable's registered 
        ComputeExtentFunction(), which may be expensive, which is why we 
        strongly encourage proper authoring of extent.
        \\sa ComputeExtent()
        \\sa \\ref UsdGeom_Boundable_Extent.
        
        An authored extent on a prim which has children is expected to include
        the extent of all children, as they will be pruned from BBox computation
        during traversal."""
    )
    uniform token orientation = "rightHanded" (
        allowedTokens = ["rightHanded", "leftHanded"]
        doc = """Orientation specifies whether the gprim's surface normal 
        should be computed using the right hand rule, or the left hand rule.
        Please see for a deeper explanation and
        generalization of orientation to composed scenes with transformation
        hierarchies."""
    )
    bool override_nodes = 0
    color3f[] primvars:displayColor (
        doc = '''It is useful to have an "official" colorSet that can be used
        as a display or modeling color, even in the absence of any specified
        shader for a gprim.  DisplayColor serves this role; because it is a
        UsdGeomPrimvar, it can also be used as a gprim override for any shader
        that consumes a displayColor parameter.'''
    )
    float[] primvars:displayOpacity (
        doc = """Companion to displayColor that specifies opacity, broken
        out as an independent attribute rather than an rgba color, both so that
        each can be independently overridden, and because shaders rarely consume
        rgba parameters."""
    )
    rel proxyPrim (
        doc = '''The proxyPrim relationship allows us to link a
        prim whose purpose is "render" to its (single target)
        purpose="proxy" prim.  This is entirely optional, but can be
        useful in several scenarios:
        
        - In a pipeline that does pruning (for complexity management)
        by deactivating prims composed from asset references, when we
        deactivate a purpose="render" prim, we will be able to discover
        and additionally deactivate its associated purpose="proxy" prim,
        so that preview renders reflect the pruning accurately.
        
        - DCC importers may be able to make more aggressive optimizations
        for interactive processing and display if they can discover the proxy
        for a given render prim.
        
        - With a little more work, a Hydra-based application will be able
        to map a picked proxy prim back to its render geometry for selection.

        \\note It is only valid to author the proxyPrim relationship on
        prims whose purpose is "render".'''
    )
    uniform token purpose = "default" (
        allowedTokens = ["default", "render", "proxy", "guide"]
        doc = """Purpose is a classification of geometry into categories that 
        can each be independently included or excluded from traversals of prims 
        on a stage, such as rendering or bounding-box computation traversals.

        See for more detail about how 
        purpose is computed and used."""
    )
    token visibility = "inherited" (
        allowedTokens = ["inherited", "invisible"]
        doc = '''Visibility is meant to be the simplest form of "pruning" 
        visibility that is supported by most DCC apps.  Visibility is 
        animatable, allowing a sub-tree of geometry to be present for some 
        segment of a shot, and absent from others; unlike the action of 
        deactivating geometry prims, invisible geometry is still 
        available for inspection, for positioning, for defining volumes, etc.'''
    )
    uniform token[] xformOpOrder (
        doc = """Encodes the sequence of transformation operations in the
        order in which they should be pushed onto a transform stack while
        visiting a UsdStage's prims in a graph traversal that will effect
        the desired positioning for this prim and its descendant prims.
        
        You should rarely, if ever, need to manipulate this attribute directly.
        It is managed by the AddXformOp(), SetResetXformStack(), and
        SetXformOpOrder(), and consulted by GetOrderedXformOps() and
        GetLocalTransformation()."""
    )
}

